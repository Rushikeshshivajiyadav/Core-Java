Exception Handling -

			1) Introduction
			2) Runtime stack mechanism
			3) Default exception handling in java
			4) Exception Hirerchy
			5) Customized exception handling by using try-catch
			6) Control flow in try-catch
			7) methods to print exception information
			8) try with multiple catch blocks
			9) finally block
			10) difference between final, finally, finalize
			11) Control flow in try-catch-finally
			12) Control flow in nested try-catch-finally
			13) various possible combination of try-catch-finally
			14) throw keyword
			15) throws keyword
			16) Exception handling keywords summary
			17) various possible compile time errors in exception handling
			18) Customized or user-defined exceptions
			19) top - 10 exceptions
			20) 1.7 version enhancements - 
						try with resources
						multi-catch block
						
				
				
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
				
				

Exception -

		1) an unexpected and unwanted event that disrupts normal flow of the program is called exception.
			eg -
				TyerPuncheredException, SleepingException, FileNotFoundException
				
		2) it is highly recommanded handle exception the main objective is graceful termination of the program
		

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

	
Exception Handling -

	1) Exception handling doesnt mean repairing exception we have to provide alternative way to continue rest of the program normally is a concept of
		exception handling
	2) our program requirement is to read data from remote file located at london at runtime if london file is not available our program should not be
		terminated ab-normally. we have to provide some local file to continue rest of the program normally. this way of defining alternative it nathing 
		but exception handling
		
		
			try{
			
				read data file from remote file location at london
			}
			catch(FileNotFoundException)
			{
				use local file & continue read of the program normally 
			}
	
	
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------	
	
	
Runtime stack mechanism -

	1) for every thread JVM will create a runtime stack 
	2) each and every methods call performed by that thread will be stored in the corresponding stack.
	3) each entry in the stack called activation record / stack frame
	4) after completing every method call the corresponding entry from the stack will be removed after completing all methods calls the stack will become empty
	5) that empty stack will be destoryed by JVM just before terminating the thread
	
	
	
	
	
			class Test 
			{
				public static void main(String [] args)
				{
					doStuff();
				}
				
				public static void doStuff()
				{
					doMoreStuff();
				}
				
				public static void doMoreStuff()
				{
					System.out.println("Hello");
				}
			}
			
			
			
			
			
			
			runtime stack for main Thread
						|
						main()				- stack frame / activation record
						|
						doStuff()
						main()
						|
						doMoreStuff()
						doStuff()
						main()
						|
						doStuff()
						main()
						|
						main()
						|
						empty 			// this empty stack will be destoryed by JVM
						
						
						
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


3) Default exception handling in java  -		
					
	1) in side the method if any exception is occurs the method which is raised is responsible to create exception object by including the following information
			1) name of exception
			2) description of exception
			3) location at which exception occurs (stack trace)
							
	2) after creating exception object method handover the object to the JVM 
	3) JVM will check weather method contains any exception handling code or not if the method doesnt contains exception handling code then JVM terminates
		the method ab-normally and remove corresponding entry from stack.
	4) then JVM idenify caller method and checks weather caller method contains any handling code or not 
	5) if the caller method doesnt contains handling code then JVM terminates that caller method also ab-normally and remove corresponding entry from stack
	6) this process will be continue until main method and main method doesnt contains handling code then JVM terminates main method also ab-normally 
		remove corresponding entry from stack.
	7) then JVM handovers responsibility of exception handling to default exception handler, which is the part of JVM
	8) default exception handler print exception information in the following format and terminates program ab-normally
		
			Exception in thread "xxx" name of exception : description 
							stack trace
						
		Example - 1
		
			class Test 
			{
				public static void main(String [] args)
				{
					doStuff();
				}
				
				public static void doStuff()
				{
					doMoreStuff();
				}
				
				public static void doMoreStuff()
				{
					System.out.println(10/2);
				}
			}	


			output -
				Exception in Thread "main" java.lang.ArithmaticException : division by zero
					at Test.doMoreStuff()
					at.Test.doStuff()
					at.Test.main()		
			




		Example - 2	
			class Test 
			{
				public static void main(String [] args)
				{
					doStuff();
					System.out.println(10/0);
				}
				
				public static void doStuff()
				{
					doMoreStuff();
					System.out.println("Hi");
				}
				
				public static void doMoreStuff()
				{
					System.out.println("Hello");
				}
			}	
			
		output -Hello 
				Hi	
			Exception in Thread "main" java.lang.ArithmaticException : division by zero
					at.Test.main()
			
			
			
			
		Note -
			1) in a program atleast one method terminates ab-normally then the program termination is ab-normally termination.
			2) if all methods terminated normally then only program termination is normal termination
			
			
			
			
			
----------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
			
			
			
			
Exception Hirerchy -
							
									
														Throwable (class)
														
														
	Exception 																							Error
	
	1) Runtime Exception 																	1) VirtualMachineError
			1) ArithmaticException																	1) StackOverflowError
			2) NullPointerException																	2) OutOfMemoryError
			3) ClassCastException
			4) IndexOutOfBoundException														2) AssertionError 
					1) ArrayIndexOutOfBoundException										3) ExceptionInInitializerError
					2) StringIndexOutOfBoundException										4) LinkageError
			5) IllegalArgumentException																1) VerifyError
					1) NumberFormatException
					
	2) I/O Exception
			1) EndOfFileException
			2) FileNotFoundException
			3) InterruptedIOException
	
	3) RemoteException 
	4) ServletException
	5) InterruptedException
	6) SQLException
	
	
	
	
	1) Throwable class access root for java exception Hirerchy.
	2) Throwable class define two child clsses exception, error
	
	
Exception -

		1) most of the time exception are caused by our program and these are recoverable
			eg- if your programmer requirement is read data from remote file locating at london at runtime time if remote file not available then we will get
			runtime exception saying FileNotFoundException
		2) if FileNotFoundException occurs we can provide local file and continue rest of the program normally
				
			
			try{
			
				read data file from remote file location at london
			}
			catch(FileNotFoundException e)
			{
				use local file & continue read of the program normally 
			}
			
			

Error -

		1) most of the time errors are not caused by our program and these are due to lock of system resources
		2) errors are not recoverable
		3) eg - if OutOfMemoryError occurs being a programmer we cant do anything and program will be terminated ab-normally
		4) System admin and server admin is responsible for increase heap memory
		
			
		
----------------------------------------------------------------------------------------------------------------------------------------------------------------
		
			
Checked Exception VS UnChecked Exception -
				
		1) the exception which are checked by compiler for smooth execution of the program at runtime are called Checked exception.
			eg - HallTicketMissingException, PenNotWorkingException, FileNotFoundException etc
		2) in our program if there is chance of raising checked exception then complusary we should handle checked exception ( either by try-catch or throws 
			keyword) otherwise will we get compile time error.
			
		3) the exceptions which are not checked by compiler weather programmer handling or not such type of exceptions are called UnChecked Exception
			eg -ArithmaticException, BombBlastException
			
		Note -
		
			1) weather its checked or UnChecked every exception occurs at runtime only , there was no chance occuring any exception at compile time
			2) runtime exception and its child clsses, Error its child clsses are UnChecked except this remaining are Checked
		


--------------------------------------------------------------------------------------------------------------------------------------------------------------------

		
Fully Checked VS Partially Checked -

		1) a checked exception said to be fully checked if and only if all its child clsses also checked
			eg - I/OException, InterruptedException
		2) a checked exception said to be partically checked if and only if some of child clsses are unchecked 
			eg - Exception, Throwable
			
			
		Note -
		
			1) the only possible partically checked exception in java are Exception, Throwable 
			


----------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
Decribe the behaviour of following Exception -

	1) IOException						- Checked / Fully Checked
	2) RuntimeException					- UnChecked 
	3) InterruptedException				- Checked / Fully Checked
	4) Error							- UnChecked 
	5) Throwable						- Checked / parcially checked
	6) ArithmaticException				- UnChecked 
	7) NullPointerException				- UnChecked 
	8) Exception						- Checked / parcially checked
	9) FileNotFoundException			- Checked / Fully Checked
	
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

	
Customized exception handling using try-catch -

	1) it is highly recommanded to handle exception. The code which may raised exception is called risky code and we have to define that code inside try-catch
		and corresponding handling code we have to define catch block
		
			try{
				risky code
			}
			catch(Exception e){
				handling code
			}
			
			
	without try-catch -
			
			class Test 
			{
				public static void main(String [] args)
				{
					System.out.println("statement 1");
					System.out.println(10/0);
					System.out.println("statement 3");
					
				}
			}	
			
			output -
				statement 1
				RE : AE : / by zero
				
				ab-normally termination
				
				
				
				
	with try-catch
			
			class Test 
			{
				public static void main(String [] args)
				{
					System.out.println("statement 1");
					try{
						System.out.println(10/0);
					}
					catch(ArithmaticException e){
						System.out.println(10/2);
					}
					
					System.out.println("statement 3");
					
				}
			}	
			
			output -
				statement 1
				5
				statement 3
				normally termination
				
				
				
				
Scanario -				
					try{
						statement 1;
						statement 2;
						statement 3;
					}
					catch(Exception e){
						statement 4;
					}
					statement 5;
			
			
			
	1) case -
			1) if there is no exception - 1,2,3,5   - normal termination
			2) if an exception raised statement 2 and corresponding catch block matched - 1,4,5 normal termination
			3) if an exception raised at statement 2 and corresponding catch block not matched - 1, ab-normally termination
			4) if an exception raised at statement 4 or 5 then its is always ab-normally termination
			
			
			note -
				1) within try block anywhere exception raised then rest of try block dont to be executed even the handled the exception, hence within try block
					we have to take only risky code and length of try block should be as less as possible
				2) in addition to try block there may to a chance of raising exception inside catch and finally block 
				3) if any statement which is not part of try block and raised exception then its always ab-normally termination
				
			
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			

methods to print exception information -

			 Throwable class define the following methods to print exception information
			
			
				method							printable format
				
			1) printStackTrace() 			name of exception : description + stack trace
			2) toString()					name of exception : description
			3) getMessage()					description
			
			
			
			class Test 
			{
				public static void main(String [] args)
				{
					try{
						System.out.println(10/0);
					}
					catch(ArithmaticException e){
					
						e.printStackTrace();
						System.out.println(e); / System.out.println(e.toString()); 
						System.out.println(e.getMessage());
					
					}
				
				}
			}	
			
			output -
				Exception in Thread "main" java.lang.ArithmaticException : division by zero
					at.Test.main()
					
				Exception in Thread "main" java.lang.ArithmaticException : division by zero
				
				division by zero
			
			
		Note -
			internally default exception handler will use printStackTrace method to print exception information to the console
			
			
			
			
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
			
try with multiple catch block -

		1) the way of handling exception is verite from exception to exception hence every exception type highly recommanded to take separate catch block that is try with
			multiple catch block always use and recommanded to use
			
			
			try{
				risky code
			}
			catch(Exception e){
				-
				-
				-
			}
			
			worst programming practice
			
			
			
			
			try{
				risky code
			}
			catch(ArithmaticException e){
				perform alternative arithmatic operations
			}
			catch(SQLException e){
				use mySQL db instead of oracle db
			}
			catch(FileNotFoundException e){
				use local file instead of remote file
			}
			catch(Exception e){
				default exception handler
			}
			
			
			Best programming practice
			
			
			
	-----------------------------------------------------------------------------------------------------------------------------------------------------

	case 1 -
	
		1) if try with multiple catch block present then the order of catch block very important we have to take child first then parent otherwise we will get 
			compile time error saying Exception XXX  has already  been caught
			
			
			try{
				System.out.println(10/0);
			}
			catch(Exception e){
				default exception handler
			}
			catch(ArithmaticException e){
				perform alternative arithmatic operations
			}
			
				output -
					CE : Exception java.lang.ArithmaticException has already been caught


	case 2 -
	
		2) we cant declare two catch block for same exception otherwise we will get compile time error
		
			try{
				System.out.println(10/0);
			}
			catch(ArithmaticException e){
				perform alternative arithmatic operations
			}
			catch(ArithmaticException e){
				perform alternative arithmatic operations
			}
			
			output -
				CE : Exception java.lang.ArithmaticException has already been caught


	case 3 -
	
		3) best and correct way
			try{
				System.out.println(10/0);
			}
			catch(ArithmaticException e){
				perform alternative arithmatic operations
			}
			catch(Exception e){
				default exception handler
			}


------------------------------------------------------------------------------------------------------------------------------------------------------

final  -
	
		1) final is modifier applicable for classes, methods and variables.
		2) if a class declared as a final we cant extends that class that is we cant create child class for that class that is inheritance not possible for final clsses.
		3) if a method is final then we cant override that method in child class
		4) if a variable declare as final then we cant perform reassignment for that variable
		
		
		
finally -

		1) finally is block always associated with try-catch to maintain clean code 
			
				try{
					risky code
				}
				catch(Exception e){
					handling code
				}
				finally{
					clean up code 
				}
				
				
		2) the specalitise of finally block is it will be executed always irrespective of weather exception is raised or not and weather handled or not.
		
		
		
finalize -
		
		1) finalize is method always invoked by garbage collector just before destorying the object to perform clean up activitices.
		2) once finalize method complete immediately garbage collector destoryed that object.
		
		
		
		Note -
		
			1) finally block is responsible to perform clean up activitices related to try block that is whatever resources we open as part of try block will be closed 			  inside finally block
			
			2) finalize method is responsible to perform clean up activitices to related to object that is whatever resources associated with object will be deallocated 
				before destorying object by using finalize method
				
				
	*****Note -
	
		finally block not executed only one condition -	
		
		example -
		
				try{
					System.exit(0);				// finally block not executed		status - 0 - normal termination / non zero - ab-normal termination
				}
				catch(Exception e){
					handling code
				}
				finally{
					clean up code 
				}


------------------------------------------------------------------------------------------------------------------------------------------------

various possible combination of try-catch-finally -

		1) in try-catch-finally order is important 
		2) whenever we are writting try compulsary we should write either catch or finally otherwise we will get compile time error that is try without catch or finally invalid
		3) whenever we writting catch block compulsary try block must be required that is catch without try is invalid
		4) whenever we are writting finally block compulsary we are try block that is finally without try is invalid
		5) inside try-catch-finally we can declare try-catch-finally block that is nesting of try-catch-finally is allowed
		6) for try-catch-finally curly braces are mandatory
		
			1) try{
					
				}
				catch(Exception e){
				
				}
			
				valid
			
			
			2)  try{
					
				}
				catch(ArithmaticException e){
				
				}
				catch(Exception e){
				
				}
			
				valid


			3) try{
					
				}
				catch(Exception e){
				
				}
				catch(Exception e){
				
				}
			
				invalid - CE : Exception XXX has already been caught


			4) try{
					
				}
				catch(Exception e){
				
				}
				finally{
				
				}
				
				valid
				
			
			5) try{
					
				}
				finally{
				
				}
				
				valid


			6) try{
					
				}
				catch(Exception e){
				
				}
				try{
					
				}
				catch(ArithmaticException e){
				
				}
				
				valid
				
				
			7) try{
					
				}
				catch(Exception e){
				
				}
				try{
					
				}
				finally{
				
				}
				
				valid
				
			
			
			8) try{
			
				}
				
				invalid - CE : try without catch or finally
				
				
			9) catch(Exception e){
				
				}
				
				invalid - CE: catch without try
				
				
			10) finally{
				
				}
				
				invalid - CE: finally without try


			11) try{
					
				}
				finally{
				
				}
				catch(Exception e){
				
				}
				
				invalid - CE: catch without try
				
				
			12) try{
					
				}
				System.out.println("Hello");
				catch(Exception e){
				
				}
				
				invalid - CE : try without catch or finally
				invalid - CE: catch without try
				
				
			13) try{
					
				}
				catch(ArithmaticException e){
				
				}
				System.out.println("Hello");
				catch(Exception e){
				
				}
				
				invalid - CE: catch without try
				
			
			14) try{
					
				}
				catch(ArithmaticException e){
				
				}
				System.out.println("Hello");
				finally{
				
				}
				
				invalid - CE: finally without try



			15)  try{
					try{
					
					}
					catch(Exception e){
				
					}
				}
				catch(Exception e){
				
				}

				valid
				
			
			
			16) try{
					try{
					
					}
				}
				catch(Exception e){
				
				}

				invalid - CE : try without catch or finally
				
				
				
			17) try{
					try{
					
					}
					finally{
				
					}
				}
				catch(Exception e){
				
				}

				valid
				


			18) try{
					
				}
				catch(Exception e){
					try{
					
					}
					finally{
				
					}
				}

				valid


			19) try{
					
				}
				catch(Exception e){
					
					finally{
				
					}
				}

				invalid - CE: finally without try
				
			
			20) try{
					
				}
				catch(Exception e){
				
				}
				finally{
					try{
					
				    }
				   catch(Exception e){
				
				     }
				}
				
				valid
			
			
			
			21) try{
					
				}
				catch(Exception e){
				
				}
				finally{
					
				   finally {
				
				     }
				}
				
				invalid - CE: finally without try
			
			
			
			22) try{
					
				}
				catch(Exception e){
				
				}
				finally{
					
				}
				finally {
				
				}
				
				invalid - CE: finally without try
				
				
				
			23) try
					System.out.println("Hello");
				catch(Exception e){
				
				}
				finally{
					
				}
				
				invalid - curly braces compulsary
			
			
			24) try{
				
				}	
				catch(Exception e)
					System.out.println("Hello");
				finally{
					
				}
			
			invalid - curly braces compulsary
			
			
			25) try{
				
				}	
				catch(Exception e){
				
				}	
				finally
					System.out.println("Hello");
			
			
			invalid - curly braces compulsary
			
			
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------------

Throw -
		
		1) some time we can create exception object explicitly we can handover to the JVM manually for this have to use throw keyword
		
			throw new ArithmaticException ("/by zero");
			
			 new ArithmaticException ("/by zero");	//	created of ArithmaticException object explicitly
			 throw - can handover to the JVM manually  	
			 
		2) hence the main objective of throw keyword is to handover our created exception object to the JVM manually
		3) hence the result of following two program is exactly same
		
		
				class Test
				{
					public static void main(String[] args){
					
					System.out.println(10/0);
					}
				}
				
				output -
				
				Exception in Thread "main" java.lang.ArithmaticException : / by zero
					at.Test.main()
			
				1) in this case main method is responsible to create exception object and handover to the JVM 
			
			
			
			
				class Test
				{
					public static void main(String[] args){
					
					throw new ArithmaticException("/by Zero");
					}
				}
				
				output -
				
				Exception in Thread "main" java.lang.ArithmaticException : / by zero
					at.Test.main()
			
			
				1) in this case programmer is created exception object explicitly and handover to the JVM manually
				
				
				
				
				
	Note -
	
		1) Best use of throw keyword is for user-defined exception and customized exception
		
		case 1 -
				
				throw e;
					if e refers null then we will get NullPointerException
					
				class Test
				{
					static ArithmaticException e = new ArithmaticException();
					public static void main(String[] args){
					
					throw e;
					}
				}
				
				output -
					RuntimeException : ArithmaticException
					
					
				class Test
				{
					static ArithmaticException e;
					public static void main(String[] args){
					
					throw e;
					}
				}
				
				output -
					RuntimeException : NullPointerException
			
			
		case 2 -

				after throw statement we are not allowed write any statement directly otherwise we will get compile time error saying unreachable statement
				
				class Test
				{
					public static void main(String[] args){
					
						System.out.println(10/0);
						System.out.println("Hello");
					}
					
				}
				
				output -
					RuntimeException : ArithmaticException :/ by zero
					
					
				
				class Test
				{
					public static void main(String[] args){
					
						throw new ArithmaticException("/by Zero");
						System.out.println("Hello");
					}
					
				}
				
				output -
					CompileError : unreachable statement
					
					
					
		case 3 -
		
				we can use throw keyword only for for throwable types if we are trying to use for normal java object we will get compile time error
				saying incompatible type 
				
				
				class Test
				{
					public static void main(String[] args){
					
						throw new Test();
					}
					
				}
				
				output -
					CompileError : incompatible types 
						found : Test
						required : java.lang.Throwable
						
					
					
				class Test extends RuntimeException
				{
					public static void main(String[] args){
					
						throw new Test();
					}
					
				}
				
				output -
					RuntimeException : Exception in thread main test
							at Test.main()
				
----------------------------------------------------------------------------------------------------------------------------------------------------------



throws -

			1) in our program if there is possibility of raising checked exception then we compulsary we should handle the checked exception otherwise we will get 
				compile time error saying unreported exception XXX ; must be caught or declared to be thrown
				
				
				import java.io.*;
				class Test
				{
					public static void main(String[] args){
					
						PrintWriter pw = new PrintWriter("abc.txt");
						pw.println("Hello");
					}
					
				}
				
				CE : unreported exception java.io.FileNotFoundException; must be caught or declared to be thrown
				
				
				
			2) 	
				
				import java.io.*;
				class Test
				{
					public static void main(String[] args){
					
						Thread.sleep(1000);
					}
					
				}
				
				CE : unreported exception java.lang.InterruptedException; must be caught or declared to be thrown
				
	we can handle this compile time error by using following two ways 

1) by using try-catch   -

				import java.io.*;
				class Test
				{
					public static void main(String[] args){
					
						try{
							Thread.sleep(1000);
						}
						catch(InterruptedException e){
							
						}
						
					}
					
				}
				
				
2) by using throws keyword -
			
			1) we can use throws keyword to deligate responsible of exception handling to the caller (it may be another method or JVM). then caller method is 
				responsible to handle that exception
				
				
				import java.io.*;
				class Test
				{
					public static void main(String[] args) throws InterruptedException{
					
							Thread.sleep(1000);
					}	
				}
				
				
			2) throws keyword for only checked exception and uses of throws for unexpected exception there is no use and no impact 
			3) throws keyword required only to convense compiler and uses of throws keyword doesnt prevent ab-normal termination of the program 
				
				
				
			class Test 
			{
				public static void main(String [] args) throws InterruptedException
				{
					doStuff();
				}
				
				public static void doStuff() throws InterruptedException
				{
					doMoreStuff();
				}
				
				public static void doMoreStuff() throws InterruptedException
				{
					Thread.sleep(1000);
				}
			}	
			
			4) in above program if you remove atleast one throws statement then the code wont compile				
				
				
		Note -
				
				1) it is recommanded to use try-catch over throws keyword
				
				
		case 1 -
				
				1) we can use throws keyword for methods and constructor but not for classes
				
					class Test throws Exception				// invalid
					{
						Test() throws Exception				//valid
						{
						}
						public void m1() throws Exception			// valid
						{
						}
					}
				
				
				
		case 2 -
				
				1) we can use throws keyword only for throwable types if we are trying to use for normal java classes then we will get compile time error
					saying incompatible types 
					
				class Test
				{
					public static void main(String[] args) throws Test{
					
					}
				}
				
				output -
					CompileError : incompatible types 
						found : Test
						required : java.lang.Throwable
						
				
				
				class Test extends Throwable/Exception/RuntimeException
				{
					public static void main(String[] args) throws Test{
					
					}
				}
				
				
		
		case 3 -	
				
				1) 
				class Test
				{
					public static void main(String[] args) {
					
						throws new Exception();		//checked exception
					}
				}
				
				
				CE: unreported exception java.lang.Exception:
					must be caught or declared to be thrown 
					
					
					
				class Test
				{
					public static void main(String[] args) {
					
						throws new Error();		//unchecked exception
					}
				}
				
				
				RuntimeException : Exception in threa "main" java.lang.Error:
					at test.main()
				
				
				
		case 4  -
		
				within try block if there is no chance of raising exception then we cant write catch block for that exception otherwise we will get compile
				time error saying exception XXX is never thrown in body of corresponding try statement
				but this rule is applicable for only for fully checked exception
				
				class Test
				{
					public static void main(String[] args) {
					
						try{
							System.out.println("Hello");
						}
						catch(ArithmaticException e){		// unchecked
							
						}
					}
				}
				
				output - Hello
				
				
				
					
					
				class Test
				{
					public static void main(String[] args) {
					
						try{
							System.out.println("Hello");
						}
						catch(Exception e){		// partically checked
							
						}
					}
				}
				
				output - Hello	
					
					
					
					
				import java.io.*;	
				class Test
				{
					public static void main(String[] args) {
					
						try{
							System.out.println("Hello");
						}
						catch(IOException e){		// fully checked
							
						}
					}
				}
				
				output - exception java.io.I/OException is never thrown in body of corresponding try statement	
					
					
					
					
					
					
				
				class Test
				{
					public static void main(String[] args) {
					
						try{
							System.out.println("Hello");
						}
						catch(InterruptedException e){		// fully checked
							
						}
					}
				}
				
				output - exception java.io.InterruptedException is never thrown in body of corresponding try statement		
					
					
					
				class Test
				{
					public static void main(String[] args) {
					
						try{
							System.out.println("Hello");
						}
						catch(Error e){		//  unchecked
							
						}
					}
				}
				
				output - Hello		
				
				
				
				
				
				
------------------------------------------------------------------------------------------------------------------------------------------------------------

Exception handling keywords summary -
		
		1) try -
				to maintain risky code
				
		2) catch -
				to maintain exception handling code
				
		3) finally - 
				to maintain clean up code 
				
		4) throw -
				to handover our created exception object to the JVM manually
				
		5) throws -
				to delegate responsibility of exception handling to the caller / JVM



------------------------------------------------------------------------------------------------------------------------------------------------------------------

various possible compile time errors in exception handling -

	1) CE : unreported exception XXX; must be caught or declared to be thrown
	2) CE : Exception XXX has already been caught
	3) CE : exception XXX is never thrown in body of corresponding try statement
	4) CE : unreachable statement
	5) CE : incompatible types 
						found : Test
						required : java.lang.Throwable
	6) CE : try without catch or finally
	7) CE : catch without try
	8) CE : finally without try
	
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Customized are User-Defined Exception -

		1) some times to meet program requirement we can define our own exception such type of exception are called customized or user-defined exception
			eg - TooYoungException, TooOldException, InSufficientFundsException
			
			// defining customized exception
			
			class TooYoungException extends RuntimeException
			{
				TooYoungException(String s)
				{
					super(s);
				}
			}
			
			
			class TooOldException extends RuntimeException
			{
				TooOldException(String s)
				{
					super(s);		// to make description available to default exception handler
				}
			}
			
			
			class CustException
			{
			
				public static void main(String[] args) {
					
						int age = Integer.parseInt(args[0]);
						if(age > 60)
						{
							throw new TooYoungException("Plz wait some more time .. you will get best match soon");
						}
						else if(age < 18)
						{
							throw new TooOldExceptionException("Your age is already crossed marriage age .... no chance to getting marriage");
						}
						else
						{
							System.out.println("you will get match details soon by email ... !!!")
						}
					}
			}
	
	
	Note -
		
		1) throw keyword is best suitable for user-defined or customized exceptions but not for predefined exception
		2) it is highly recommanded to define customized exception as unchecked that is we have to extends RuntimeException but not Exception
		3) super(s);		// to make description available to default exception handler



-----------------------------------------------------------------------------------------------------------------------------------------------------------------

top - 10 exceptions  -
		
		 based on the person who is raising a exception all exceptions are divided into 2 categories 
		
		1) JVM Exception
		2) Programmatic Exception
	
		1) JVM Exception -
			1) the exception which are raised automatically by the JVM whenever a particular event occurs are called JVM Exception
				eg - ArithmaticException, NullPointerException, etc
			
		2) Programmatic Exception -
			1) the exception which are raised explicitly either by programmer or API developer to indicate the something goes wrong are called Programmatic Exception
				eg - TooOldException, TooYoungException, IllegalArgumentException, etc
				
				
				
				
	1) ArrayIndexOutOfBoundException -
					
			1) it is the child class of runtime exception and hence it is unchecked
			2) raised automatically by JVM whenever we are trying to access array element with out of range index
				eg -
				
					int [] x = new int[];
					
					System.out.println(x[0]);		// 0
					System.out.println(x[10]);		// RuntimeException : ArrayIndexOutOfBoundException
					System.out.println(x[-10]);		// RuntimeException : ArrayIndexOutOfBoundException
			
				
				
				
	2) NullPointerException -
			
			1) it is child class of runtime exception and hence it is unchecked
			2) raised automatically by JVM whatever we are trying to perform any operation on null 
			
					String s = null;
					System.out.println(s.length()); 	// RuntimeException : NullPointerException
					
				
				
	3) ClassCastException -
						
			1) it is child class of runtime exception and hence it is unchecked
			2) raised automatically by the JVM whenever we are trying to typeCase parent object to child type 
			
					String s = new String("Rushikesh");
					Object o = (Object) s;				// valid
					
					
					Object o = new Object();	
					String s = (String) o;			RuntimeException : ClassCastException
					
					
					Object o = new String("Rushikesh");
					String s = (String) o;					// valid
					
				
				
				
	4) StackOverflowError -
					
			1) it is child class of error and hence it is unchecked
			2) raised automatically by the JVM whenever we are trying to perform recursive method call
			
			
				class Test 
				{
					public static void m1()
					{
						m2();
					}
					
					public static void m2()
					{
						m1();
					}
					
					public static void main(String [] args)
					{
						m1();
					}
				}
				
				
				output - RuntimeException : StackOverflowError
				
				
				
	5) NoClassDefFoundError -
			
			1) it is child class of error and hence it is unchecked
			2) raised automatically by the JVM whenever JVM unable to find required .class file
				eg -
					java Test
					
			3) if Test.class not available then we will get RuntimeException saying NoClassDefFoundError: Test
				
				
				
				
	6) ExceptionInInitializerError	-

			1) it is child class of error and hence it is unchecked
			2) raised automatically by the JVM whenever if any exception occurs while executing static variable assignment and static block
			
			
			class 
			{
				static int a = 10/0;
			}
			
			RuntimeException : ExceptionInInitializerError
				Caused by : java.lang.ArithmaticException : / by zero
				
			
				
				
			class 
			{
				static 
				{
					String s = null;
					System.ot.println(s.length());
				}
			}
			
			RuntimeException : ExceptionInInitializerError
				Caused by : java.lang.NullPointerException	
				
				
				
				
	7) IllegalArgumentException -

			1) it is the child class of RuntimeException and hence it is unchecked
			2) raised explicitly either by programmer or by API developer to indicate that a method has been invoked with IllegalArgument
			3) the valid range of Thread priority 1 to 10 if you are trying to set a priority with any other value then we will get runtime exception saying 
				IllegalArgumentException
				
				Eg -
					Thread t = new Thread ();
					t.setPriority(7);			// valid
					t.setPriority(15);			// RuntimeException : IllegalArgumentException
					
				
				
				
	8) NumberFormatException - 

			1) it is the direct child class of IllegalArgumentException which is the child class of RuntimeException and hence it is unchecked
			2) raised explicitly either by programmer or API developer to indicate that we are trying to convert String to Number. and the String is not properly formatted
				
				eg -
				
					int i = Integer.parseInt("10");			// valid
					int i = Integer.parseInt("ten");		// 	RuntimeException : NumberFormatException
					
					
					
					
	9) IllegalStateException -					
					
			1) it is the child class of RuntimeException and hence it is unchecked		
			2) raised explicitly either by programmer or by API developer to indicate that a method has been invoked at wrong time
			3) after starting of a thread we not allowed to restart same thread otherwise we will get RuntimeException saying IllegalStateException
			
				eg -
					Thread t = new Thread();
					t.start(); 				//	valid
					t.start(); 				// RuntimeException : IllegalStateException
					
					
					
					
					
	10) AssertionError -
			
			1) it is the child class of Error and hence it is unchecked
			2) raised explicitly either by programmer or by API developer to indicate that Assert statement failed
			
				eg -
					assert (x > 10);
					
			3) if x is not greater than 10 then we will get RuntimeException saying AssertionError
			
			
			


				Exception / Error												raised by 
				
			1) ArrayIndexOutOfBoundException
			2) NullPointerException
			3) ClassCastException
			4) StackOverflowError								raised automatically by JVM and hence these are JVM exceptions
			5) NoClassDefFoundError
			6) ExceptionInInitializerError
			
			
			7) IllegalArgumentException
			8) NumberFormatException							raised explicitly either by programmer or by API developer and hence these are Programmatic exceptions
			9) IllegalStateException
			10) AssertionError
				
				
				
				
				
-------------------------------------------------------------------------------------------------------------------------------------------------------------------


1.7 version enhancements - 

			as the part of 1.7 version in exception handling following two concept introduced 
			
			1) try with resources -
			2) multi-catch block -	 			
				
				
		1) try with resources -
				
				1) until 1.6 version it is highly recommanded to write finally block to close resources which are open as part of try block
				
					BufferReader br = null;
					try{
						br = new BufferReader (new FileReader("input.txt"));
						use br based on our required
					}
					catch(I/OException e){
						handling code 
					}
					finally{
					
						if(br != null)
						{
							br.close();
						}
					}
				
				
				2) the problems in this approach are compulsary programmer is required to close resources inside the finally block it is increases the complexicity 
					of programming
				3) we have to write finally block compulsary and hence it increases length of the code and reduced readability 
				4) to overcome above problems sun peoples introduced try with resources in 1.7 version
				5) the main advantages of try with resources is whatever resources is open as part of try block will be closed automatically once control reaches end
					of try block either normally or ab-normally and hence we are not required  to close explicitly so the complexicity of program to br reduced
				6) we are not required to write finally block so the length of the code be reduced and readability will be improved
				
				
				
				
				try(BufferReader br = new BufferReader (new FileReader("input.txt")) )			// resource
				{
					use br based on our required
					br will be closed automatically once control reaches end of 
					try block either normally or ab-normally and hence we are not required  to close explicitly
					
				}
				catch(I/OException e){
						handling code 
					}
				
				
				
				7) we can declare multiple resources but these resources should be separated to be ; semicolon
				
					try(R1,R2,R3){
						
					}
					
					eg -
						try(FileWriter fw = new FileWriter("input.txt"); FileReader fr = new FileReader("input.txt"))
						{
						
						}
						
				
				
				8) All resources should be autoclosable resources
				9) resources is said to be autoclosable if and only if corresponding class is implements java.lang.Autoclosable interface
				10) all I/O related resources, databases related resources, network related resources or already implemented autoclosable interface 
				11) being a programmer we are not required to do any thing just we aware the point 
				12) autoclosable interface came in 1.7 version and it contains only one method close
						public void close();
						
				
				13) all resource reference variable are implicitly final and hence within try block we cant perform reassign otherwise we will get compile time error
				
					eg -
					
						import java.io.*;
						class TryWithResources
						{
							public static void main(String [] args)
							{
								try(BufferReader br = new BufferReader(new FileReader("input.txt")))
								{
									br =  new BufferReader(new FileReader("output.txt"));
								}
							}
					
						}
						
						output -
							autoclosable resource br may not be assigned 
				
				
				
				14) until 1.6 version try with associated with either catch or finally but 1.7 version onward we can take only with resource without catch or finally
				
					eg -
						try(R){
							
						}
				
				15) the main advantages of try with resource is we are not required to write finally block explicitly because we are not required to close resources explicitly
					hence until 1.6 version finally block is just like hero but from 1.7 version onward it is dummy becomes Zero
					
					
		

		---------------------------------------------------------------------------------------------------------------------------------------------------------

	2) multi-catch block -
			
				
			1) until 1.6 version even the multiple different exception having same handling code for every exception type we have to write separate catch block
			2) it increases length of the code and reduced readability
			
				try{
				
				}
				catch(ArithmaticException e)
				{
					e.printStackTrace();
				}
				catch(I/OException e)
				{
					e.printStackTrace();
				}
				catch(NullPointerException e)
				{
					System.out.println(e.getMessage());
				}
				catch(InterruptedException e)
				{
					System.out.println(e.getMessage());
				}
				
			3) to overcome this problem sun peoples introduced multi-catch block in 1.7 version
			4) according to this we can write single catch block that can handle multiple different type of exception
			
				
				
				try{
				
				}
				catch(ArithmaticException | I/OException e)
				{
					e.printStackTrace();
				}
				catch(NullPointerException | InterruptedException e)
				{
					System.out.println(e.getMessage());
				}
				
				
			5) the main advantages of these approach is length of code is reduced and readability will be improved

			
				try{
					System.out.println(10/0);
					String s = null ;
					System.out.println(s.length());
				}
				catch(ArithmaticException | NullPointerException e)
				{
					e.printStackTrace();
				}
				
				
			6) in the above example weather raised exception is either ArithmaticException or NullPointerException the same catch block can listen
				
			7) in multi-catch block should not be any relation between exception type (either child to parent, parent to child , same type) otherwise we will get
				compile time error
				
					
				try{
				
				}
				catch(ArithmaticException | Exception e)
				{
					e.printStackTrace();
				}
				
				output -
					CE : Alternatives in a multi-catch statement cannot be related by subclassing
					
					
					
					
					
					
					
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Exception Propogation -
		
		1) inside a method exception is raised and if we are not handling that exception then exception object will be propogated to caller then caller method 
			responsible to handle exception this process is called Exception Propogation
			

Re-Throwing Exception -

		1) we can use this approach to convert one exception type to another exception type
		
			
				try{
					System.out.println(10/0);
					
				}
				catch(ArithmaticException e)
				{
					throw new NullPointerException();
				}