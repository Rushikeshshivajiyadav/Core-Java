Collection -

	Arrays -
			1) the Arrays is an indexed Collection of fixed number of homogeneous data elements
			2) the main Advantages is we can represent multiple values by using single variable so that readability of code is improved
	
	
	Limitations of Arrays -
	
		1) Arrays are fixed in size.
				- that is once we create an Array there is no chance of increment/ decrement Array based on our requirement due to this to use Array concept compulsary we should
					know size in advance which may not possible always
					
		2) Arrays can hold only homogeneous element.
				- 
					Student[] s = new Student[10000];
					s[0] = new Student();
					s[1] = new Customer();			// CE : incompatible types   found : Customer   required : Student
					
					
			we can solve this problems using by Object type Array
			
					Object[] o = new Object[10000];
					a[0] = new Student();			// valid
					a[1] = neew Customer();			// valid
					
					
					
				
		3) no underline data structure - no ready made methods  -
		
					- Array concept is not implemented based on some standard data structure and hence ready made method support is not available for every requirement we have to 
						write code implicity which increses complecity of program
						
						
		4) to overcome above problems of Arrays we should go for Collections concept
		
		
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		
	Collection -
	
		1) Collections are growable - increment / decrement based on our requirement
		2) Collection can hold both homogeneous & Hydrogeneous element
		3) every collection class implemented based on some standard data structure - ready made methods by default available
		
				- hence for every requirement ready made method support is available 
				- being a programmer we are responsible to use those methods and we are not responsible to implement those methods
		
		
---------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		
		
Differences between Arrays and Collections -
					
					Arrays																Collections
					
			1) Arrays are fixed in size that is once we create Array				1) Collections are growable in nature based on our requirement we can increse and 
				we cant increse and decrese size based on requirement					decrese the size
				
			2) with respect with memory Arrays are not recommended to use 			2) with respect with memory Collections are recommended to use
		
			3) with respect to performance Arrays are recommended to use 			3) with respect to performance Collections are not recommended to use
			
			4) Arrays can hole only homogeneous data types elements 				4) Collections can hold both homogeneous and hetrogenuaus elements
			
			5) there is no underline data structure for Arrays and hence			5) Every Collections data structure based on some standard data structure and hence
				ready made method support is not available for every requirement		for every requirement ready made method support is available being a programmer we can 
				we have to write code which increment complexity of programming			use this method directly and we are not responsible for implement those method
				
				
			6) Arrays can hole both primitive, Object 								6) Collections can hold only Object types but not primitives
			
			



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------			


conclusions  -
			
		1) performance wise array is better than collection
		2) memory wise collection is better than array
		3) Arrays is lang.package feature and collection is API feature
		4) array can hold primitive, Object and collection can hold only Objects
		
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------

		
	Collection -
		collection is group of indiviual object as a single entity then should go for collection.
		
		
		
	collection framework -
		collection framework contains several classes and interfaces which can used to represent group of indiviual object as a single entity 
		
	
	
			java 												c++
			
			
		Collection										Container
		
		Collection framework							STL (Standard Template library)
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------------



9 key interfaces of collection framework -


		1) Collection
		2) List 
		3) Set
		4) SortedSet
		5) NavigableSet
		6) Queue
		7) Map
		8) SortedMap
		9) NavigableMap
		
		
		1) Collection(I) -(1.2 version)
		
				1) if want to represent a group of indiviual Objects in a single entity then should be go for Collection
				2) Collection interface root element of collection framework
				3) Collection interface define the most common methods which are applicable for any collection object like add, remove
				4) there is no concurrent class which implements collection interface directly 
				
				
		

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Difference between Collection(I) vs Collections(C)		
		
		Collection(I) VS Collections(C) -
		
			1) Collection is a interface which can used to represent group of indiviual object as a single entity
			2) Collections is a class which define serveral utility methods for collection object 
			
					Collections.sort(l);
					Collections.searching();
					
				Collections class is utility class present in java.utils package to define utility methods for collection object (sorting, searching etc)
		


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		
		2) List(I) - (1.2 version)
		
			1) List is child interface of Collection interface
			2) group of indiviual object as a single entity if you want to allowed duplicates and insertion order must be preserved then we should go for List 
			3) ArrayList(1.2 version), LinkedList(1.2 version)
			4) Vector(1.0 version), Stack(1.0 version) - legacy classes
			 
			Note  -
			
				in 1.2 version Vector And Stack classes are re-enginerred/Modified to implement List Interface
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			
		
		3) Set(I) -(1.2 version)
		
			1) Set is child interface of Collection Interface
			2) group of indiviual object as a single entity where duplicates are not allowed and insertion order not required then we should go for Set 
			3) HashSet(1.2 version), LinkedHastSet(1.4 version)
			

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------			
		
		4) SortedSet(I) - (1.2 version)
			1) SortedSet is child interface of Set Interface
			2) group of indiviual object as a single entity where duplicates are not allowed and All objects are inserted according to some sorting
			   Order
			   


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			   
		5) NavigableSet(I) - (1.6 version)
			1) It is child interface of SortedSet interface
			2) it contains serveral methods for navigation purposes
			3) TreeSet(1.2 version) is implemented class of NavigableSet interface
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			
			
	Difference between List VS Set
				
					List									Set
					
			1) duplicates are allowed				duplicates are not allowed
			2) Insertion order preserved 			Insertion order not preserved
			
		
		
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


		
		6) Queue(I) - (1.5 version) -
		
			1) Queue is child interface of Collection Interface
			2) if we want to represent group of indiviual object Prior to processing then we should go for Queue.
			3) visual Queue followed FIFO but based our required we can implement our own priority also
			
				eg -
					1) before sending a mail all email id we have to store in some data structure 
					2) in which order we added email id in the same order only mail should be delivered for this requirement Queue is best choice
				
			
			4) PriorityQueue class(1.5 version) 
			5) BlockingQueue(1.5 version)  - PriorityBlockingQueue, LinkedBlockingQueue
			
			
			
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
			All the about interfaces (Collection, List,Set, SortedSet, NavigableSet, Queue) meant for representing a group of indiviual objects 
			if we want to represent a group of objects as key values pairs then we should go for Map
		
		
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


		7) Map - (1.2 version) -
		
			1) Map interface is not child of Collection Interface
			2) if we want to represent a group of objects as key values pairs then we should go for Map
			3) both key and value are objects only 
			4) duplicates keys are not allowed but values can be duplicates
			5) HashMap (1.2 version) - LinkedHastMap (1.4 version)
			6) WeakHashMap (1.2 version), IdentityHashMap (1.4 version)
			7) Dictionery (AC)Hashtable - Properties (1.0 version) legacy classes
			
			
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			
		8) SortedMap(I) (1.2 version) -
		
			1) It is child interface of Map Interface
			2) if we want to represent group of key value pairs according to some sorting order of keys then we should go for SortedMap
			3) in sorting map the sorting should be based on key but not based on value
			
			 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------


		9) NavigableMap - (1.6 version) -
		
			1) it is child Interface of SortedMap interface
			2) it contains serveral methods for navigation purposes
			3) TreeMap class (1.2 version)
			
			
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	Hierarchy of Collection and Map interface  -

	
																	
																		Collection(I) 1.2
																		
																		
											List(I) 1.2											Set(I) 1.2												Queue(I) 1.5
																		
																		
																						
					ArrayList(C) 1.2	LinkedList(C) 1.2	Vector(C) 1.0				HashSet(C)1.2			SortedSet(I)1.2				PriorityQueue1.5  BlockingQueue	1.5			
																		
																		
															Stack(C) 1.0				LinkedHastSet(C)1.4		NavigableSet(I)1.6							PriorityBlockingQueue 1.5
																		
																		
																												TreeSet(C) 1.2								LinkedBlockingQueue 1.5
																		
																		
											



														
															Map(I) 1.2														Dictionery(AC) 1.0
															
															
															
				HashMap	1.2				WeakHashMap 1.2			IdentityHashMap	1.4			SortedMap(I) 1.2						Hashtable 1.0
				
				
				LinkedHastMap 1.4															NavigableMap(I) 1.6					Properties 1.0
				
				
																								TreeMap 1.2
			
			
			
			
----------------------------------------------------------------------------------------------------------------------------------------------------------------------


			Sorting -
			
			1) Comparable - nature sorting 
			2) Comparator - Custom Sorting
			
			
			you get objects one by one then use 
			Cursurs -
					Enumeration (1.0 version) , Iterator , ListIterator
					
			utility classes -
					Collections, Arrays
					
			


---------------------------------------------------------------------------------------------------------------------------------------------------------------------

			
		the following are legacy characters present in Collection framework -
		
			Enumeration(I), Dictionery(AC), Vector(C), Stack(C), Hashtable(C) , Properties(C)
			
			
			
			
			
			
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
				
			
Collection(I) -

		1) if we want to represent group of an indiviual object as a single entity then we should go for collection
		2) Collection interface defines most common methods which are applicable of any collection objects
		
	Methods -
	
		    boolean add(Object o),
			boolean addAll(Collection c), 
			boolean remove(Object o), 
			boolean removeAll(Collection c), 
			void clear(),
			boolean retainAll(Collection c) - except this collection all objects are removed
			boolean contains(Object o),
			boolean containsAll(Collection c)
			boolean isEmpty()
			int size(),
			Object[] toArray(),
			Iterator iterator()
			
			
		Note -	
		
		4) there is no concurrent class which implements Collection Interface directly
		
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------------


List(I) -

		1) List is child interface of Collection interface
		2) group of indiviual object as a single entity if you want to allowed duplicates and insertion order must be preserved then we should go for List
		3) we can preserved insertion order via Index and we can differenciate duplicate objects by using index. hence index will play very important role in List
		
	
	Methods -
	
			void add(int index, Object o)
			boolean addAll(int index, Collection c)
			Object remove(int index)
			Object get(int index)
			Object set(int index, Object o) - to replace the element present at specified index with provided Object and returns old object
			int indexOf(Object o) - return index of first occurrence of o
			int lastIndexOf(Object o)
			
			ListIterator listIterator()
			
	implement classes - 
			
			ArrayList, LinkedList, Vector, Stack
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------
		

ArrayList(C) -

		1) The underline data structure is resizable Array or growable Array
		2) duplicates are allowed
		3) insertion order is preserved
		4) hetrogenuaus Object are allowed	(except TreeSet and TreeMap everywhere hetrogenuaus elements are allowed)
		5) null insertion is allowed
		6) create empty ArrayList object with default initial capacity 10
		7) we add 11th Object then automatically create new ArrayList and copy all element into new ArrayList with reference and old ArrayList is 
		   available for garbage Collection
		   
		   
		   
	constructor  -
	
		1) ArrayList l = new ArrayList();      // constructor default initial capacity 10
		
				once ArrayList is exceed max capacity then a new ArrayList object will be created with new capacity
				new capacity = current capacity * 3/2 + 1
		
		2) ArrayList l = new ArrayList(int initialCapacity);    // constructor
				create empty ArrayList with specified initialCapacity
				
		3) ArrayList l = new ArrayList(Collection c);      // constructor
				create a equalant ArrayList object of given Collection.
				
				
	Example  -
				import java.util.*;
				
				class ArrayListDemo{
				
					public static void main(Strig[] args){
					
						ArrayList al = new ArrayList();
						al.add("A");
						al.add(10);
						al.add("A");
						al.add(null);
						
						System.oy.println(al); 			// [A, 10, A, null]
						al.remove(2);
						System.oy.println(al); 			// [A, 10, null]
						al.add(2, "M");
						al.add("N");
						System.oy.println(al); 			// [A, 10, M, null, N]
					}
				}
	


	conclusions  -
	
		1) usually we can use collections to hold and transfer objects from one location to another location (Container)
			to provide support for this requirement every Collection class by default implements Serializable, Cloneable Interfaces
			
		2) ArrayList And Vector classes implement RandomAccess interface so that any random element we can access with same speed.
		
				The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.
				
		3) RandomAccess Interface present in Java.util package and it doesn't contains any methods Its is a Marker Interface. where required ability
		    will be provided automatically by the JVM
			
			
			eg - 
			
				ArrayList al = new ArrayList();
				LinkedList ll = new LinkedList();
				
				System.out.println(al instanceof Serializable);			// true
				System.out.println(ll instanceof Cloneable);			// true
				System.out.println(al instanceof RandomAccess);			// true
				System.out.println(ll instanceof RandomAccess);			// false
			
		4) ArrayList is best choice if our frequent operation is retrival operation because ArrayList implement RandomAccess interface
		
		5) ArrayList is worst choice if our frequent operation is insertion and deletion in the middle. 
				
		
			
			Note -
			
				1) TreeSet, TreeMap hetrogenuaus element not allowed in Collection framework remaining All places hetrogenuaus element are allowed
				
				2) Collection Object like [A, 10, A, null]
					Map Object like {101=durga, 102=rushi,103=abhi}
				
				3) For data safety we use Generics (1.5 version) 
				
				4) Every Collection class implements Serializable Interface, Cloneable Interface
					A serializable interface is used to persist an object
				    The cloneable interface is used to clone the class objects
				    Both these interfaces are marker interfaces i.e. they are empty.
					
					
					
---------------------------------------------------------------------------------------------------------------------------------------------------------------------					
					
		Difference between ArrayList VS Vector
					ArrayList											   							Vector
			1) Evrey methods present in the ArrayList is non-synchronised				Evrey methods present in the Vector is synchronised
			
			2) At a time multiple Thread allowed to operate on ArrayList object 		At a time Only one Thread allowed to operate on Vector object
				and hence is not Thread-safe											and hence is Thread-safe
				
			3) relatively performance is high because threads not required to 		   relatively performance is low because threads are wait for 	
				wait to operate on ArrayList Object										operate on Vector Object
				
			4) introduced in 1.2 version and it is non legacy				   			introduced in 1.0 version and it is legacy
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

How to get synchronised version of ArrayList Object -

			
		By default ArrayList is non-synchronised but we can get synchronised version of ArrayList Object by using synchronisedList() method of Collections class
		
			public static List synchronisedList(List l);
			
			example -
			
			ArrayList l = new ArrayList();						// l non synchronised
			List l1 = Collections.synchronisedList(l);			// l1 synchronised
			
			
			
		similarly we can get synchronised version of Set And Map object by using the following methods of Collections class
			public static Set synchronisedSet(Set s)
			public static Map synchronisedMap(Map m)
			
			
			
			
			
			
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
			
LinkedList(C) -

		1) underline data structure is double linkedList insertion order is preserved and duplicate objects are allowed
		2) hetrogenuaus element are allowed
		3) null insertion is allowed
		4) LinkedList is implement serializable and cloneable interface but not RandomAccess interface
		5) linkedList is best choice if frequent operation is insertion and deletion in middle
		6) LinkedList is worst choice if your frequent operation is retrival operation
		7) no term of capacity in LinkedList
		
		
	constructor  -
	
		1) LinkedList l = new LinkedList();		//constructor
			create an empty linkedList object 
			
		2) 	LinkedList l = new LinkedList(Collection c);			//constructor
			create an equalant LinkedList object for  the given Collection
	
	
	Methods -
	
		   linkedList class specific methods visually we can used linkedList to develeop stack and queue to provide support for this requirement 
		   linkedList class define the following specific methods
		   
		   void addFirst(Object o)
		   void addLast(Object o)
		   Object getFirst()
		   Object getLast()
		   Object removeFirst()
		   Object removeLast()
		   
		   
	Example  -
				import java.util.*;
				
				class LinkedListDemo{
				
					public static void main(Strig[] args){
					
						LinkedList ll = new LinkedList();
						ll.add("Durga");
						ll.add(30);
						ll.add(null);
						ll.add("Durga");				// [Durga, 30, null, Durga]
						ll.set(0, "Software");			// [Software, 30, null, Durga]
						ll.add(0, Vicky);				// [Vicky, Software, 30, null, Durga]
						ll.removeLast();				// [Vicky, Software, 30, null]
						ll.addFirst("CCC");				// [CCC, Vicky, Software, 30, null]
						System.out.println(ll); 		// [CCC, Vicky, Software, 30, null]
					}
				}
		   
		   
		   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------		   
		   
		   
	Difference between ArrayList VS LinkedList
	
					ArrayList											   							LinkedList
					
			1) ArrayList is best choice if your frequent operation 						linkedList is best choice if your frequent operation is insertion
				is retrival operation													and deletion in middle
			
			2) ArrayList is worst choice if your frequent operation is insertion  		linkedList is worst choice if your frequent operation is 
				and deletion because internally serveral shift operation are			retrival operation				 
				 performed
				
			3) in ArrayList element will be store consecutive memory location		   in LinkedList element will be don't be store in consecutive memory location	
				hence retrival operation will be easy									hence retrival operation will be difficult
				




--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Vector(C) - (1.0 version)

		1) underline data structure is resizable Array or growable Array
		2) insertion order is preserved
		3) duplicates are allowed
		4) hetrogenuaus objects are allowed
		5) null insertion is possible
		6) it implements Serializable, Cloneable
		7) Every methods present in Vector is synchronised and hence Vector Object is Thread-safe
		
	
	constructor -
	
		1) Vector v = new Vector();          // constructor
				create an empty Vector Object with default initial capacity 10 . once Vector reaches max capacity then new Vector object will be created wih
			new capacity = current capacity *2 ;
			
		2) Vector v = new Vector(int initialCapacity);      // constructor
				create an empty Vector object with specified initial capacity
			
		3) Vector v = new Vector(int initialCapacity, int incrementcapacity);  
		   
		4) Vector v = new Vector(Collection c); 
				creates equalant Vector Object for the given collection. this constructor meant for interconversion between Collection Objects
				
				
	Methods  -
	
			addElement(Object o)
			removeElement(Object o)
			removeElementAt(int index)
			removeElementAll()
			Object elementAt(int index)
			object firstElement()
			Object lastElement()
			int size()
			int capacity()
			Enumeration element()
			
			
	Example  -
				import java.util.*;
				
				class VectorDemo{
				
					public static void main(Strig[] args){
					
						Vector v = new Vector();
						System.out.println(v.capacity()); 		// 	10
						
						for(int i=1; i<=10; i++){
							
							v.addElement(i);
						}
						
						System.out.println(v.capacity()); 		// 	10
						v.addElement("A");
						System.out.println(v.capacity()); 		// 	20
						System.out.println(v); 					// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, A]
					}
				}		
				
				
				
				
---------------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
			
			
Stack(C) -

		1) it is a child class of Vector
		2) It is a specially designed class for last in first order(LIFO)
		3) for adding element insertion order preserved using index but at the time of removing we use offset 
		
	constructor -
	
		1) Stack s = new Stack();
		
		
	Methods -
	
			Object push(Object o)
			Object pop()
			Object peek() - return top of the stack without remove
			boolean empty()
			int search(Object o) - returns offset if the element is available otherwise return -1
			
			
			
			
	Example  -
				import java.util.*;
				
				class StackDemo{
				
					public static void main(Strig[] args){
					
						Stack s = new Stack();
						s.push("A");
						s.push("B");
						s.push("C");
						
						System.out.println(s); 					// 	[A, B, C]
						System.out.println(s.search("A")); 		// 	3
						System.out.println(s.search("Z")); 		// 	-1
					}
				}	
			
			
			
			
			offset								index
			
			1				C					2
			2				B					1
			3				A					0
			


---------------------------------------------------------------------------------------------------------------------------------------------------------------
			
			
Cursurs -

		if we want ot get Objects one by one from Collection then we should go for Cursurs. there are 3 types of Cursurs in java 
		
		1) Enumeration
		2) Iterator
		3) ListIterator
		
		
		
	1) Enumeration -(1.0 version)
	
			1) we can use Enumeration to get Objects one by one from legacy collection objects.
			2) we can create Enumeration object using elements() method of Vector class
				public Enumeration elements()
				
				eg -
				
				Enumeration e = v.elements();
				
		Methods -
				
				public boolean hasMoreElements();
				public Object nextElement();
				
		
		Example -
		
				import java.util.*;
				
				class VectorDemo{
				
					public static void main(Strig[] args){
					
						Vector v = new Vector();
						
						for(int i=1; i<=10; i++){
							
							v.addElement(i);
						}
						
						System.out.println(v); 					// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
						
						Enumeration e = v.elements();
						
						while(e.hasMoreElements()){
						
							Integer i = (Integer) e.nextElement();
							if(i%2 == 0){
								
								System.out.println(i);			// [2, 4, 6, 8, 10]
							}
							else{
							
								System.out.println(i + "will be removed");
								v.remove(i);
								System.out.println(v);			// [1, 3, 5, 7, 9]
							}
						}
						System.out.println(v);			// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
					}
				}	
			
				
		limitions of Enumeration -
		
			1) we can apply Enumeration concept only for legacy classes and it not a universal cursur
			2) by using Enumeration we can get only read access and we cant perform remove operation.
			3) to overcome about limitions we should go for Iterator.
			
			
			
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------

	
			
	Iterator -(1.2 version) -
		
			1) we can appling Iterator concept for any Collection Objects and hence it is universal cursur.
			2) by using Iterator we can perform both read and remove operation
			3) we can create Iterator Object by using iterator() of Collection interface
			
				public Iterator iterator();
				
				eg -
					Iterator itr =c.iterator();
					
		Methods -
				
				public boolean hasNext();
				public Object next();
				public void remove();
				
				
		Example -
		
				ArrayList l = new ArrayList();
				
				for(int i=0;i<=10;i++)
				{
					l.add(i);
				}
				
				System.out.println(l);				// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
				
				Iterator itr = l.iterator();
				while(itr.hasNext){
					Integer I = (Integer)itr.next();
					if(I%2==0)
						System.out.println(I);			// [0, 2, 4, 6, 8, 10]
					else
						itr.remove();
					
				}
				System.out.println(l);				// [0, 2, 4, 6, 8, 10]
				
				
				
				
				
				
		limitions of Iterator -
		
			1) by using Enumeration under Iterator we can always move only towards forward direction and we cant move towards backword direction
			2) this is single direction cursur but not bi-direction cursur
			3) by using Iterator we can perform only read and remove operation and we cant perform replace and add new object
			4) to overcome about limitions we should go for ListIterator
			
			
			
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
			
			
			
			
ListIterator -
	
		1) by using ListIterator we can move either forward direction and backword direction and hence it is Bi-direction cursur
		2) by using ListIterator we can perform replacement and addition of new objects in addition to read and remove operation.
		3) we can create ListIterator by using listIterator() method of List Interface
		
				public ListIterator listIterator();
				
				eg -
				ListIterator itr = l.listIterator();			//l - any list objects
				
		4) ListIterator is child interface of Iterator and hence all methods present in Iterator by default available in ListIterator.
		
			
	Methods -
	
			Forward direction -
				public boolean hasNext();
				public Object next();
				public int nextIndex();
			
			Backword direction -
				public boolean hasPrevious();
				public Object previous();
				public int previousIndex();
			
			Extra operation	-		
				public void remove();
				public void add(Object o);
				public void set(Object o);
			
			
			
			
	Example  -
			import java.util.*;
			
			class ListIteratorDemo{
			
				public static void main(Strig[] args){
				
					LinkedList l = new LinkedList();
					l.add("Rushikesh");
					l.add("Abhi");
					l.add("Nayana");
					l.add("Vishal");
					
					System.out.println(l);				// [Rushikesh, Abhi, Nayana, Vishal]
					
					ListIterator itr = l.listIterator();
					
					while(itr.hasNext()){
						String s = (String) itr.next();
						if(s.equals("Abhi"))
							itr.remove();
						else if(s.equals("Nayana"))
							itr.add("Banti");
						else if(s.equals("vishal"))
							itr.set("Rama");
					}
					
					System.out.println(l);			// [Rushikesh, Nayana, Banti, Rama]	
				}
			}
			
			
			
			
	Note -
	
		1) the most powerful Cursur is ListIterator but its limitions is it is applicable for only List Object
			
-----------------------------------------------------------------------------------------------------------------------------------------------------------------			
			
			
			
comparization table of Three cursurs  -		
			
			
					
				property 									Enumeration 					Iterator						ListIterator
			
			1) where we can apply 					only for legacy classes				for any collection objects			only for List Objects
			2) its legacy ?							yes (1.0 version)					no (1.2 version)					no (1.2 version)
			3) movement 							single direction (only forward)	    single direction (only forward)		Bi-direction
			4) allowed operation					only read							read / remove 						read / remove /replace /add
			5) how we can get 						by using elements() method of 		by using iterator() method of		by using listIterator() method of
													Vector class						Collection (I)						List(I)
			6) methods								hasMoreElements(), 					hasNext(), next(), remove();		9 methods
													nextElement()


	note -
	
	
			import java.util.*;
			
			class ListIteratorDemo{
			
				public static void main(Strig[] args){
				
					Vector v = new Vector();
					
					Enumeration e = v.elements();
					Iterator itr = v.iterator();
					ListIterator litr = v.listIterator();
		
					// get implemented class name of Enumeration Interface
					
					System.out.println(e.getClass().getName());       	// java.util.Vector$1
					System.out.println(itr.getClass().getName());       // java.util.Vector$Ltr
					System.out.println(litr.getClass().getName());       // java.util.Vector$ListItr
				}
			}





-------------------------------------------------------------------------------------------------------------------------------------------------------------




Set(I) -

		1) Set is child interface of Collection Interface
		2) if we want to represent indiviual objects as a single entity where duplicates are not allowed and insertion order not preserved
		3) Set interface doesnt contains any new methods and we have to use only Collection interface methods.
	
	
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------


HashSet() -

			1) The underline data structure is Hashtable.
			2) duplicates objects are not allowed
			3) insertion order is not preserved and it is based on HashCode of Object
			4) null insertion is possible(only once).
			5) hetrogenuaus objects are allowed
			6) implement serializable, cloneable but not RandomAccess interface
			7) HashSet is best choice if it frequent operation is serach operation
			
	Note -
			1) in HashSet duplicates are not allowed if you are trying to insert to duplicate we want to get compiler time error add method simply returns false.
			
				HashSet hs = new HashSet();
				System.out.println(hs.add("Rushikesh"));    // true
				System.out.println(hs.add("Rushikesh"));    // false
				
				
				
	constructor -
	
			1) HashSet hs = new HashSet();
				create an empty HashSet Object with default initial capacity 16 and default fill ratio 0.75
				
			2) HashSet hs = new HashSet(int initialCapacity);
				creates an empty HashSet Object with specified initial capacity and default fill ratio 0.75
				
			3) HashSet hs = new HashSet(int initialCapacity, float fillRatio);
				
			4) HashSet hs = new HashSet(Collection c);
				creates equalant HashSet Object for the given collection. this constructor meant for interconversion between Collection Objects
				
				
				
	fillRatio / LoadFactor -
	
			1) after filling how much ratio a new HashSet Object will be created , this ratio is called fillRatio or LoadFactor
				eg -
					fillRatio 0.75 means after filling 75% ratio a new HashSet object will be created.
					
					
					
					
					
	Example -				
			import java.util.*;
			
			class HashSetDemo{
			
				public static void main(Strig[] args){
				
					HashSet h = new HashSet();
					h.add("B");
					h.add("C");
					h.add("D");
					h.add("Z");
					h.add(null);
					h.add(10);
					
					System.out.println(h.add("Z"));       	// false
					System.out.println(h);      			 // [null, D, B, C, 10, Z]
					
				}
			}				
					

-------------------------------------------------------------------------------------------------------------------------------------------------------------------




LinkedHastSet - 

		1) It is a child class of HashSet 
		2) it is exactly same as HashSet(including constructor and methods) except following differences
		
		
		
	Difference between HashSet VS LinkedHashSet -
	
					HashSet											   							LinkedHashSet
			1) underline data structure is Hashtable						underline data structure is combination of LinkedList and Hashtable
			
			2) Insertion order not preserved								Insertion order preserved
				
			3) introduced in 1.2 version									introduced in 1.4 version
			

			
			LinkedHashSet lhs = new LinkedHashSet();
			lhs.add("A");
			lhs.add("D");
			lhs.add("C");
			lhs.add(null);
			lhs.add(10);
			System.out.println(lhs.add("Z"));				//false
			System.out.println(lhs.add("Z"));	[A, D, C, null, 10]



----------------------------------------------------------------------------------------------------------------------------------------------------------------


Cache Memory -

		1) in general we can use LinkedHashSet to develeop Cache based application where duplicates are not allowed and insertion order preserved
		
		
		
		
					primary memory				<------    Cache Memory     <------------ secondary Memory
																|
																
															duplicate not allowed
															insertion order preserved
		


---------------------------------------------------------------------------------------------------------------------------------------------------------------

		
SortedSet -


		1) SortedSet is child interface of Set interface
		2) if we want to represent group of indiviual Object according to some sorting order without duplicates then we should go for SortedSet 
		


	Methods  -
		
			SortedSet interface defines the following specific methods
		
			Object first() - returns first element of SortedSet 
			Object last() - returns last element of SortedSet
			SortedSet headSet(Object o) - returns  SortedSet whose elements are less than o
			SortedSet tailSet(Object o) - returns  SortedSet whose elements are >= o
			SortedSet subSet(Object o1, Object o2) - returns  SortedSet whose elements are >= o1  and <o2
			
			Comparator comparator()-
			
					returns Comparator Object that decribes underlying sorting technique.
					if we are using default natural sorting order then we will get null
					
					
	Example -
	
					[100,101,104,106,110,115,120]
					
					first() - 100
					last()  - 120
					headSet(106) - 100,101,104
					tailSet(106) - 106,110,115,120
					subSet(101,115) - 101,104,106,110
					
		
		Note -
					numbers - Ascending order
					String - Alphabetical order
					
					
					
					
--------------------------------------------------------------------------------------------------------------------------------------------------------------------					
										
TreeSet -

		1) underline data structure is balanced tree
		2) duplicates objects are not allowed
		3) insertion order not preserved
		4) hetrogenuaus objects are not allowed otherwise will get runtime ClassCastException 
		5) null insertion possible only once
		6) TreeSet implement Serializable, Cloneable interface but not RandomAccess interface
		7) All objects will be inserted based on some sorting order it may be default sorting order or customized sorting order
		
		
		
	constructor -
	
			1) TreeSet t = new TreeSet();
				create an empty TreeSet Object where element will be inserted according to default natural sorting order
				
			2) TreeSet t = new TreeSet(Comparator c);
				create an empty TreeSet object where the element will be inserted according to customized sorting order specified the Comparator Object
				
			3) TreeSet t = new TreeSet(Collection c);
				creates equalant TreeSet Object for the given collection.
				
			4) TreeSet t = new TreeSet(SortedSet s);
			
			
			
			
				
				
	Example -				
			import java.util.*;
			
			class TreeSetDemo{
			
				public static void main(Strig[] args){
				
					TreeSet t = new TreeSet();
					t.add("A");
					t.add("a");
					t.add("B");
					t.add("Z");
					t.add("L");
					
					t.add(new Integer(10));			// ClassCastException
					t.add(null);					// nullPointerException
					
					System.out.println(t); 			[A,B,L,Z,a]
					
				}
			}				
				
				
	
	
	
	null acceptance -
	
			1) for non empty TreeSet if we trying to insert null then we will get nullPointerException
			2) for empty TreeSet as first element null is allowed but after inserting that null if you trying to insert any other then we will get runtime exception
				saying nullPointerException
				
			note -
			
			* until 1.6 version null is allowed as first element to the empty TreeSet but from 1.7 version on words null is not allowed even null is first element 
			  null such type of story not applicable for TreeSet 
			  
			  
			  
		Example -	
		
			import java.util.*;
			
			class TreeSetDemo{
			
				public static void main(Strig[] args){
				
					  TreeSet t = new TreeSet();
					  t.add(new StringBuffer("A"));
					  t.add(new StringBuffer("Z"));
					  t.add(new StringBuffer("B"));
					  t.add(new StringBuffer("L"));
					  t.add(new StringBuffer("M"));
					  t.add(new StringBuffer("X"));		
					  
					  System.out.println(t); 			[]
			  
					
				}
			}		  
			 
			  
				RE - ClassCastException
			  
			  1) if we are depending on default natural sorting order compulsary object should be homogeneous and Comparable otherwise we will get runtime Exception
				 saying ClassCastException
			  2) The Objects should be Comparable if and only if corresponding class implements Comparable Interface.
			  3) String Class and all wrapper classes already implements Comparable Interface. but StringBuffer class doesnt implement Comparable interface
			  4) hence we got ClassCastException in the above example
			  
			  
			  
			  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------			  

			  
	Comparable (I) -
	
			1) It is present in Java.lang package and it contains only one method compareTo()
			
				public int compareTo(Object obj);
					
					obj1.compareTo(obj2)
						- return   -ve if & obj1 has to come before obj2
						- returns   +ve if & obj1 has to come after obj2
						- returns    0 if & obj1 & obj2 are equal
						
						
						
				System.out.println("A".compareTo("Z"));			// -ve
				System.out.println("Z".compareTo("K"));			// +ve
				System.out.println("A".compareTo("A"));			// 0
				System.out.println("A".compareTo(null));		RE - nullPointerException
						
				
				obj1.compareTo(obj2)
					obj1 - the object, which is to be inserted
					obj2 - the object is already inserted
					
					
			3) if we are depending on default natural sorting order then while adding object into the TreeSet JVM will call compareTo() method
			
				TreeSet t = new TreeSet();
				t.add("k");				// no comaparize
				t.add("Z");				// Z.compareTo("K")		+
				t.add("A");				// A.compareTo("Z")		-	
				t.add("A");				// A.compareTo("A")		0
				
				System.out.println(t); [A,K,Z]
				
				
				
				
		Note -
		
			1) if default sorting order not available if you are not satisfy with default natural sorting order then we can go for customized sorting using
				Comparator Interface
				
				
					Comparable meant for Default Natural Sorting Order
					Comparator meant for Customized Sorting Order
				
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
				
				
				
Comparator(I) -

		1) Comparator present in java.util package and its defines two methods compare() and equals()
		
				public int compare(Object o1, Object o2)
				
						- return   -ve if & obj1 has to come before obj2
						- returns   +ve if & obj1 has to come after obj2
						- returns    0 if & obj1 & obj2 are equal
						
						
				public boolean equals(Object o)
				
				
		2) whenever we implementing Comparator interface compulsary provide implementtion only for compare method we are not required implemention for equals
			because it is already available to our class from Object class through inheritance
			
			
			
		Q.	Write a program to insert Integer Object into the TreeSet where the sorting order is descending order
			
	

	Example -
			
			class MyComparator implements Comparator
			{
				public int compare(Object o1, Object o2){
				
					Integer I1 =(Integer) o1;
					Integer I2 =(Integer) o2;
					
					if(I1 < I2)
						return +1;
						
					else if (I1 >2)
						return -1;
						
					else
						return 0;
				}
			}
				

			import java.util.*;
			
			class TreeSetDemo{
			
				public static void main(Strig[] args){
				
					TreeSet tt = new TreeSet(new MyComparator());				// line 1
					
					tt.add(10);				
					tt.add(0);					// compare(0,10)
					tt.add(15);					// compare(15,10)
					tt.add(5);					// compare(5,10), compare(5,0)
					tt.add(20);					// compare(20,10), compare(20,15)
					tt.add(20);					//compare(20,10), compare(20,15), compare(20,20)
					System.out.println(tt);     //[20,15,10,5,0]			[]
			  
					
				}
			}	
			
			
			
		1) at line 1 if you are not passing Comparator Object then internally JVM call compareTo method which is means for default natural sorting order
		2) in this case output will [0,5,10,15,20]
		3) at line one if you are passing comparator object then JVM call compare method which is means for customized sorting 
		4) in this case output is [20,15,10,5,0]
		
		
		
		
		Different Cases to use compareTo method
		
	Example  -
	
	
		class MyComparator implements Comparator
			{
				public int compare(Object o1, Object o2){
					Integer I1 =(Integer) o1;
					Integer I2 =(Integer) o2;
					
					
					1) return o1.compareTo(o2); 			// default natural sorting order - Assecding [0,5,10,15,20]
					2) return -o1.compareTo(o2);			// descending order [20,15,10,5,0]
					3) return o2.compareTo(o1); 			// descending order [20,15,10,5,0]
					4) return -o2.compareTo(o1); 			//  Assecding [0,5,10,15,20]
					5) return +1; 							// insertion order [10,0,15,5,20,20]
					6) return -1;							// reverse of insertion order [20,20,5,15,0,10]
					7) return 0;							// only first element will be inserted and all remaining will duplicates [10]
				}
			}
				
				
				

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------				
				
TreeSet with String Object    -


	Q.	Write a program to insert String Object into the TreeSet where all element should be inserted according to reverse of alphabetical order
		
		
			import java.util.*;
		
			class TreeSetDemo{
			
				public static void main(Strig[] args){
				
					TreeSet tt = new TreeSet();
					tt.add("Rushikesh");
					tt.add("Rahul");
					tt.add("Abhishek");
					tt.add("Anil");
					tt.add("Vishal");
					tt.add("Akash");
					System.out.println(tt);				//  [Abhishek, Akash, Anil, Rahul, Rushikesh, Vishal]
			  
					TreeSet tt = new TreeSet(new MyComparator);
					tt.add("Rushikesh");
					tt.add("Rahul");
					tt.add("Abhishek");
					tt.add("Anil");
					tt.add("Vishal");
					tt.add("Akash");
					System.out.println(tt);				//  [Vishal, Rushikesh, Rahul, Anil, Akash,Abhishek]
				}
			}	
		
				
				
		
			class MyComparator implements Comparator
			{
				public int compare(Object o1, Object o2){
					String I1 =(String) o1;				// typeCasting only for String Object
					String I2 =o2.toString();			// typeCasting for all String, StringBuffer, StringBuilder
					
					return -o1.compareTo(o2);			[Vishal, Rushikesh, Rahul, Anil, Akash,Abhishek]
					return o2.compareTo(o1);  			[Vishal, Rushikesh, Rahul, Anil, Akash,Abhishek]
				}
			}
			
			
			
-------------------------------------------------------------------------------------------------------------------------------------------------------------------


TreeSet with StringBuffer Object   -
			
		Write a program to insert StringBuffer into the TreeSet where sorting order is alphabetical order
		
		
			import java.util.*;
		
			class TreeSetDemo{
			
				public static void main(Strig[] args){
				
					TreeSet tt = new TreeSet(new MyComparator);
					tt.add(new StringBuffer("Rushikesh"));
					tt.add(new StringBuffer("Rahul"));
					tt.add(new StringBuffer("Abhishek"));
					tt.add(new StringBuffer("Anil"));
					tt.add(new StringBuffer("Vishal"));
					tt.add(new StringBuffer("Akash"));
					System.out.println(tt);				//[Abhishek, Akash, Anil, Rahul, Rushikesh, Vishal]
				
				}
			}	
				
				
				
			class MyComparator implements Comparator
			{
				public int compare(Object o1, Object o2){
					String I1 =o1.toString();			// typeCasting for all String, StringBuffer, StringBuilder	
					String I2 =o2.toString();			// typeCasting for all String, StringBuffer, StringBuilder
					
					return o1.compareTo(o2);			[Abhishek, Akash, Anil, Rahul, Rushikesh, Vishal]
					
				}
			}
			
			
		Note -
		
			1) if we are depending on default natural sorting order compulsary object should homogeneous and comaparable otherwise will we get runtime saying
				ClassCastException 
			2) if you are define our own sorting by comparator by then objects need not be comaparable and homogeneous that is we can add hetrogenuaus 
				non comaparable object also 
				
				
				
	Q. Write a program to insert String and StringBuffer into the TreeSet where sorting order is incresing length order if two having same length 
		then consider there alphabetical order
			
			import java.util.*;
		
			class TreeSetDemo{
			
				public static void main(Strig[] args){
				
					TreeSet tt = new TreeSet(new MyComparator);
					tt.add("A");
					tt.add(new StringBuffer("ABC"));
					tt.add(new StringBuffer("AA"));
					tt.add("XX");
					tt.add("ABCD");
					tt.add("A");
					System.out.println(tt);     [A,AA,XX,ABC,ABCD]
				
				}
			}
			
					
			class MyComparator implements Comparator
			{
				public int compare(Object o1, Object o2){
					String s1 =o1.toString();			// typeCasting for all String, StringBuffer, StringBuilder	
					String s2 =o2.toString();			// typeCasting for all String, StringBuffer, StringBuilder
					
					int l1=s1.length();
					int l2=s2.length();
					
					if(l1 < l2)
						return -1;
					else if(l1 > l2)
						return +1;
					else
						return s1.compareTo(s2);
					
				}
			}
				
				
				
				
	----------------------------------------------------------------------------------------------------------------------------------------------------------------------------		
			
		
		predefined comparable classes -				predefined comparable classes -				our own classes (Employee) -
			String 										StringBuffer								Employee
				|											|											|
			comparator									Comparator								The person who is written the class (Comparable) DNSO

																								The person who is useing the class (Comparator) customized order
				
	


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
				
				
	1) Comparable what is say Comparator -
	
		1) by predefined comparable classes default natural sorting order already available if we are not satisfy with that default natural sorting order then we 
			can define own sorting order by using Comparator
			
		2) for predefined non- comaparable classes (like StringBuffer) default natural sorting order not already available we can define our own sorting
			by using Comparator
		
		3) our own classes like Employee, the person who is written the class is responsible to define default natural sorting order by implementing Comparable 
			interface
			
		4) the person who is using, if he is not satisfy with default natural sorting order he can define your own sorting order
				
				
				
	Example  -			
				
			class Employee implements Comparable
			{
				String name;
				int eid;
				
				Employee(String name, int eid)
				{
					this.name=name;
					this.eid=eid;
				}
				
				public String toString()
				{
					return name+ "--" + eid;
				}
				
				public int compareTo(Object o)
				{
					int eid1 = this.eid;
					Employee e = (Employee)obj;
					int eid2 = e.eid;
					
					if(eid1 < eid2)
						return -1;
					else if (eid1 > eid2)
						return 1;
					else 
						return 0;
				}
				
			
			}
			
			class MyComparator 
			{
				public static void main(Strig [] args) {
					
					Employee e1 = new Employee(	"Rushikesh",100);
					Employee e2 = new Employee(	"Abhishek",200);
					Employee e3 = new Employee(	"Akash",50);
					Employee e4 = new Employee(	"Vishal",150);
					Employee e5 = new Employee(	"Rushikesh",100);
					
					TreeSet tt = new TreeSet();
					tt.add(e1);
					tt.add(e2);
					tt.add(e3);
					tt.add(e4);
					tt.add(e5);
					
					System.out.println(tt);			//[Akash, Rushikesh,Vishal, Abhishek]  - eid
					
					TreeSet ttt = new TreeSet(new Comparator());
					ttt.add(e1);
					ttt.add(e2);
					ttt.add(e3);
					ttt.add(e4);
					ttt.add(e5);
					
					System.out.println(ttt);		//[Abhishek, Akash, Rushikesh, Vishal] - name
				}
			}
			
			Class MyComparator implements Comparator
			{
				public int compare(Object obj1, Object obj2)
				{
					Employee e1 = (Employee) obj1;
					Employee e2 = (Employee) obj2;
					
					String s1 = e1.name;
					String s2 = e2.name;
					
					return s1.compareTo(s2);       // [Abhishek, Akash, Rushikesh, Vishal] - name
				}
			}
				
				
				
				
				
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
				
				
Comparisan of Comparable and Comparator -
					
					
					Comparable																	Comparator
					
					
			1) default natural sorting order								1) customized sorting order
			2) java.lang package											2) java.util
			3) only one method - compareTo									3) two methods - compare, equals
			4) All wrapper classes and String implements 					4) Collator, RuleBasedCollator GUI develeop
				comparable interface
					
					
					
					
					
					
---------------------------------------------------------------------------------------------------------------------------------------------------------------------					
					
					
comparison table of Set implemention classes -
	
		properties 								HashSet 						LinkedHashSet 						TreeSet
		
		1) underline data structure 		Hashtable						linkedList + Hashtable				balanced tree
		2) duplicate objects 				not allowed						not allowed						    not allowed
		3) insertion order 					not preserved					preserved							not preserved
		4) Sorting order 					not applicable					not applicable						applicable
		5) hetrogenuaus objects				allowed							allowed								not allowed
		6) null acceptance 					allowed							allowed								allowed for empty TreeSet as first element allowed until 1.6
																												onward 1.7 null is not allowed even first element also
		
		
					
					
					
					
--------------------------------------------------------------------------------------------------------------------------------------------------------------------					
					
					
Map -
							
							
							
														
															Map(I) 1.2											

																																Dictionery(AC) 1.0
															
															
															
				HashMap	1.2				WeakHashMap 1.2			IdentityHashMap	1.4			SortedMap(I) 1.2						Hashtable 1.0
				
				
				LinkedHastMap 1.4															NavigableMap(I) 1.6					Properties 1.0
				
				
																								TreeMap 1.2
			
			
			
			
					
					
					
					
					
Map (I)  -
						
			1) Map is not child interface of Collection
			2) if we want to represent a group of Objects as key-value pairs then we should go for Map.
			
			
					Entry 						Key				value
												
												101				Durga
												102				Ravi
												103				Shiva
												104				Pavan
												
												
												
			3) both keys and values are Objects only
			4) duplicate keys are not allowed but values can be duplicated
			5) each key-value pairs is called Entry hence Map is consider as a Collection of Entries Object
		
		
	Methods -
											
			1) Object put(Object key, Object value)  -
					- to add one key-value pair to the Map
					- if the key is already present then old value will be replaced with new value and return old value that the reason return type Object
					
					
				eg -
					m.put(101,"Durga");				101 - Durga   Replaced with Ravi
					m.put(102,"Shiva");				102 - Shiva
					m.put(101,"Ravi");				101 - Ravi 		--> 101 - Durga    return old value
					
					
					{101=Ravi, 102=Shiva} 
					
					
			2) void putAll(Map m) -
			
			3) Object get(Object key) -
					- returns the value associated with specified key otherwise null value 
					
			4) Object remove(Object key) -
					- remove the entry associated with specified key
					
			5) boolean containsKey(Object key) -
			
			6) boolean containsValue(Object value) -
			
			7) int size() -
			
			8) void clear() -
			
			9) boolean isEmpty() -
			
			
			
	Collection views of Map  -
			
			1) Set keySet() -
			2) Collection values() -
			3) Set entrySet() -
			
			
			
			
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


Entry(I)  -
			
			1) a Map is a group of key-value pair and each key-value pair is called as Entry 
			2) hence Map is consider as Collection of Entry Objects
			3) without existing Map object there is no chance of existing Entry Object hence Entry interface is define inside Map interface
			
				interface Map{
					
					interface Entry{
					
						// Entry specific method and we can apply only on Entry Object
						
						Object getKey();
						Object getValue();
						Object setValue(Object newObj);
						
					}
				}
			
			
			
			
------------------------------------------------------------------------------------------------------------------------------------------------------------------


HashMap  -
		
			1) the underline data structure is Hashtable 
			2) insertion order not preserved and it is based on hashCode of keys
			3) duplicate keys are not allowed but values can be duplicated
			4) hetrogenuaus Objects are allowed both both key and value 
			5) null is allowed of key (only once)
			6) null is allowed for value (any number of time)
			7) HashMap implements Serializable and Cloneable interface but not RandomAccess 
			8) HashMap is best choice if our frequent operation is serach operation
			
			
			
	constructor -
	
			1) HashMap hm = new HashMap();
				create an empty HashMap Object with default initial capacity 16 and default fill ratio 0.75
				
			2) HashMap hm = new HashMap(int initialCapacity);
				creates an empty HashMap Object with specified initial capacity and default fill ratio 0.75
				
			3) HashMap hm = new HashMap(int initialCapacity, float fillRatio);
				
			4) HashMap hm = new HashMap(Map p);
				creates equalant HashMap Object for the given Map. this constructor meant for interconversion between Map Objects
				
						
	Example  -	
			
			import java.util.*;
		
			class HashMapDemo 
			{
				public static void main(Strig [] args) {
					
					HashMap hm = new HashMap();
					hm.put("chiranjeevi", 700);
					hm.put("balaiah", 800);
					hm.put("venkatesh", 200);
					hm.put("nagarjuna", 500);
					
					System.out.println(hm);					//{nagarjuna=500, venkatesh=200, balaiah=800, chiranjeevi=700}
					
					System.out.println(hm.put("chiranjeevi", 1000));		// 700
					
					Set s = hm.keySet();
					System.out.println(s);						// [nagarjuna, venkatesh, balaiah, chiranjeevi]
					
					Collection c = hm.values();
					System.out.println(c);						// [500, 200, 800, 1000]
					
					Set s1 = hm.entrySet();
					System.out.println(s1);						// [nagarjuna=500, venkatesh=200, balaiah=800, chiranjeevi=1000]


					Iterator itr = s1.iterator();
					while(itr.hasNext()){
						
						Map.Entry m1 = (Map.Entry) itr.next();
						System.out.println(m1.getKey() +"..... "+ m1.getValue());			// key ... value
						
						if(m1.getKey().equals("nagarjuna")){
							
							m1.setValue(3000);
						}
					}
					
					System.out.println(hm);						//{nagarjuna=3000, venkatesh=200, balaiah=800, chiranjeevi=1000} 
				}
			}
			
		
		
		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


Differences between HashMap and Hashtable  -		
		
		
		
							HashMap																Hashtable
							
				1) every method present in HashMap is non-synchronised				1) every method is present in Hashtable synchronised
				
				2) at a time multiple Threads are allowed to operate on 			2) at a time only one Thread is allowed to operate on Hashtable and hence
					HashMap Object and hence it is not Thread-safe						it is Thread-safe
					
				3) relatively performance is high because Threads are not 			3) relatively performance is low because Threads are required to wait to operate once
					required to wait to operate on HashMap Object						Hashtable Object
					
				4) null is allowed to both key-value								4) null is not allowed for key-value otherwise we will get nullPointerException
				
				5) Introduced in 1.2 version and it is not legacy 					5) Introduced in 1.0 version and it is legacy 
				
				
				
				
				
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


How to get synchronised version of HashMap Object -

		
			1) bydefault HashMap is non-synchronised but we can get synchronised version of HashMap by using synchronisedMap() method of Collections class
			
					
				eg -
					HashMap hm = new HashMap();
					Map m1 = Collections.synchronisedMap(hm);
						
						m1 - synchronised
						hm - non-synchronised
		
		
		
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


LinkedHastMap   -
			
			1) it is the child class of HashMap
			2) it is exactly same as HashMap (including methods and constructors) except the following differences
			
			
						
											HashMap														LinkedHastMap
		
		
					1) underline data structure is Hashtable								1) underline data structure is a combination of LinkedList + Hashtable
																								(hybrid)
																								
					2) insertion order not preserved and it is based on 					2) insertion order is preserved
						hashCode keys
						
					3) Introduced in 1.2 version											3) Introduced in 1.4 version
		
		
		
	Example -

	
			import java.util.*;
		
			class LinkedHashMapDemo 
			{
				public static void main(Strig [] args) {
					
					LinkedHashMap lhm = new LinkedHashMap();
					lhm.put("chiranjeevi", 700);
					lhm.put("balaiah", 800);
					lhm.put("venkatesh", 200);
					lhm.put("nagarjuna", 500);
					
					System.out.println(lhm);					//{chiranjeevi=700, balaiah=800, venkatesh=200, nagarjuna=500}
					 
				}
			}
		
		
		
		
		1) in the above HashMap problems if we replace HashMap with LinkedHashMap then output is that is insertion order is preserved
		
		
		
		Note -
				
			1) LinkedHashSet and LinkedHashMap are commanlly used for develeping Cache based application
			
			
			
			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Difference between == operator and .equals() method -
		
			
			1) in general == operator meant for reference comparison (Address comaparize) where as .equals() meant for content comparison
			
			2) eg -
					
					Integer I1 = new Integer(10);
					Integer I2 = new Integer(10);
					
					System.out.println(I1 == I2);					// false
					System.out.println(I1.equals(I2));				// true
					
					
		
		
		
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


IdentityHashMap -		
		
		
			1) it is exactly same as HashMap(including methods and constructors) except the following differences
			
				- in the case of normal HashMap JVM will use .equals() to identify duplicate keys which is meant for content comparison
				- in the case IdentityHashMap JVM will use == operator to identify duplicate keys which is meant for reference / address comparison
				
				
				eg -
					
					import java.util.*;
					
					class HashMapDemo{
					
						public static void main(Strig[] args){
						
							HashMap hm = new HashMap();
							
							Integer I1 = new Integer(10);
							Integer I2 = new Integer(10);
							
							hm.put(I1, "Pawan");
							hm.put(I2, "Kalyan");
							
							System.out.println(hm);					// {10=Kalyan}
							
						}
					}
		
		
		
					I1  -	10;
					I2 	- 	10;
					
			
			1) I1 and I2 are duplicate keys because I1.equals(I2) return true
			2) if we replace HashMap with IdentityHashMap then I1 and I2 are not duplicate keys because I1 == I2 return false
			3) in this case output is 
					
				{10=Pawan, 10=Kalyan}	
			
		
		
		
		
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------


WeakHashMap  -		

		
			1) it is exactly same as HashMap except the following difference 
				
					- in the case of HashMap even those Object doesnt have any reference it is not eligible for GC if it is associated with HashMap that is HashMap dominate 
						Garbage Collator
					- in the case of WeakHashMap, if Object doesnt contain any references it is eligible for GC even those Object associated with WeakHashMap that is 
						Garbage Collator dominate WeakHashMap
						
						
				eg -
						
					import java.util.*;
					
					class WeakHashMapDemo{
					
						public static void main(Strig[] args) throws Exception{
						
							HashMap hm = new HashMap();
							Temp t = new Temp();
	
							hm.put(t, "Pawan");
							System.out.println(hm);					// {t=Pawan}
							
							t = null;
							System.gc();
							Thread.sleep(5000);
							System.out.println(hm);					// {t=Pawan}
							
						}
					}
					
					
					class Temp{
						
						public Strig toString(){
							
							return "temp";
						}
						
						public void finalize(){
						
							System.out.println("Finalized method called");
						}
					}
			
		
		
		1) in the above example temp Object not eligible for GC because it is associated with HashMap in this case output is
				
				{temp = Pawan}
				{temp = Pawan}
				
		2) in the above program we can replace HashMap with WeakHashMap then temp object eligible for GC in this case output is 
				
				{temp = Pawan}
				Finalized method called
				{}
				
		
		
		
		
----------------------------------------------------------------------------------------------------------------------------------------------------------------------


SortedMap   -
				
			
			1) it is child interface of Map
			2) if we want to represent a group of key-value pair according to some Sorting order of keys then we should go for SortedMap
			3) Sorting is based on the keys but not based on value
			
			
			
	Methods -
	
			  SortedMap defines the following specific methods -
				
			1) Object firstKey() -
			2) Object lastKey() -
			3) SortedMap headMap(Object key) -
			4) SortedMap tailMap(Object key) -
			5) SortedMap subMap(Object key1, Object key2);
			6) Comparator comparator() -
			
			
			eg -
			
				101		A
				102		B 
				103		C 
				104		D 
				105		E 
				106		F
				
				
				firstKey() -					// 101
				lastKey() -						// 106
				headMap(104) -					// {101=A, 102=B, 103=C}
				tailMap(104) -			// {104=D, 105=E, 106=F}
				subMap(102, 106));		// {102=B, 103=C, 104=D, 105=E}
				comparator() -			// null
			
		
		
		
		
		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


TreeMap  -
				
			
			1) the underline data structure is RED/BLACK Tree
			2) insertion order not preserved and it is based on some sorting order of keys
			3) duplicates keys are not allowed but values can be duplicated
			4) if we are depending on default natural sorting order then keys should be homogeneous and comparable otherwise we will get runtime exception saying 
				ClassCastException
			5) if we are defining our own sorting order then keys need not be homogeneous and comparable we can take hetrogenuaus and non-comaparable elements also
			6) weather we are depending on default natural sorting order or customized sorting order there are no restriction for values we can take hetrogenuaus non-comaparable
				object also
				
				
				
				
				
	Null acceptance  -
			
			1) for non empty TreeMap if we trying to insert an Entry with null key then we will get nullPointerException
			2) for empty TreeMap as first entry with null is allowed but after inserting that entry if you trying to insert any other then we will get runtime exception
				saying nullPointerException
				
			note -
			* until 1.6 version null acceptance rule is allowed only but from 1.7 version on words null is not allowed for key
			
			but for values we can use null any number of times there is no restriction weather it is 1.6 version or 1.7 version
			   
		
		
	constructors -
		
			1) TreeMap tm = new TreeMap();
					for default natural sorting order
				
			2) TreeMap tm = new TreeMap(Comparator c);
				for customized sorting order 
				
			3) TreeMap tm = new TreeMap(Map m);
				creates equalant TreeSet Object for the given collection.
				
			4) TreeMap tm = new TreeMap(SortedMap sm);
		
		
		
		
	Example -
			
			import java.util.*;
			
			class TreeMapDemo{
			
				public static void main(Strig[] args){
					
					TreeMap t = new TreeMap();
					t.put(100, "ZZZ");
					t.put(103, "YYY");
					t.put(101, "XXX");
					t.put(104, 106);
					t.put("FFF", "XXX");				// ClassCastException
					t.put(null, "XXX");					// nullPointerException
					
					System.out.println(t)			// {100=ZZZ, 101=XXX, 103=YYY, 104=106}
				}
			}
		
		
		
		2) Customized Sorting order -
		
		
			import java.util.*;
			
			class TreeMapDemo{
			
				public static void main(Strig[] args){
					
					TreeMap t = new TreeMap(new MyComparator);
					t.put("XXX", 10);
					t.put("AAA", 20);
					t.put("ZZZ", 30);
					t.put("LLL", 40);
					
					System.out.println(t)			// {ZZZ=30, XXX=10, LLL=40, LLL=20}
				}
			}
			
			
			class MyComparator implements Comparator{
			
				public int compare(Object o1, Object o2){
				
					String s1 = o1.toString();
					String s2 = o2.toString();
					
					return s2.compareTo(s1);
				}
				
			}
		
		



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Hashtable   -

			1) the underline data structure for Hashtable is Hashtable
			2) insertion order is not preserved and it is based on HashCode of keys 
			3) duplicate keys are not allowed and values can be duplicated
			4) hetrogenuaus Objects are allowed for both keys and values 
			5) null is not allowed for both key and value otherwise we will get runtime Exception saying nullPointerException
			6) it implements Serializable and Cloneable interfaces but not RandomAccess
			7) every method present in Hashtable is synchronised and hence Hashtable object is Thread-safe
			8) Hashtable is best choice if our frequent operation is serach operation
			
			
	
	constructors  -
		
			1) Hashtable ht = new Hashtable()  -	
						crearte an empty Hashtable object and default initial capacity 11 and default fill ratio 0.75
						
			2) Hashtable ht = new Hashtable(int initialCapacity)  -
						
			
			3) Hashtable ht = new Hashtable(int initialCapacity, float fillRatio)  -
			
			4) Hashtable ht = new Hashtable(Map m)  -



	Example -
	
			class Temp{
				
				int i;
				
				Temp(int i){
					this.i = i;
				}
				
				public int hashCode(){
					
					return i;
				}
				
				public String toString(){
				
					return i+ "";
				}
			}

			
			import java.util.*;
			
			class HashtableDemo{
			
				public static void main(String [] args){
				
					Hashtable ht = new Hashtable();
					
					ht.put(new Temp(5), "A");
					ht.put(new Temp(2), "B");
					ht.put(new Temp(6), "C");
					ht.put(new Temp(15), "D");
					ht.put(new Temp(23), "E");
					ht.put(new Temp(16), "F");
					
					ht.put("Durga", null);			// nullPointerException
					
					System.out.println(ht);			//	{6=C, 16=F, 5=A, 15=D, 2=B, 23=E}
				}
				
			}


			




					10
					
					9
					
					8
					
					7
					
					6		6=C
					
					5		5=A, 16=F
					
					4		15=D
					
					3
					
					2		2=B
					
					1
					
					0		23=E	




					15 % 11  = 4
					23 % 11  = 1
					16 % 11  = 5

					From top to bottom and right to left
					
					
					{6=C, 16=F, 5=A, 15=D, 2=B, 23=E}



		if we change hashCode method of has as 
		
				public int hashCode(){
				
					return i%9;
				}
				
				
					10
					
					9
					
					8
					
					7		16=F
					
					6		6=C, 15=D
					
					5		5=A, 23=E
					
					4		
					
					3
					
					2		2=B
					
					1
					
					0			




					15 % 9  = 6
					23 % 9  = 5
					16 % 9  = 7

					From top to bottom and right to left
					
					
					{16=F, 15=D, 6=C, 23=E, 5=A, 2=B}



		if we configure initialCapacity as 25 that is 
			
			Hashtable ht = new Hashtable(25);
			
					
					
					24
					
					23		23=E
					
					22
					
					21
					
					20
					
					19
					
					18
					
					17
					
					16		16=F
					
					15		15=D
					
					14
					
					13
					
					12
					
					11
					
					10
					
					9
					
					8
					
					7		
					
					6		6=C 
					
					5		5=A 
					
					4		
					
					3
					
					2		2=B
					
					1
					
					0	
					
					
					
					{23=E, 16=F, 15=D, 6=C, 5=A, 2=B}
					
					
					
					
					
					
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Properties   -
		
				
			1) in our program if anything which changes frequently like username, password, email-id, mobile-no etc or not recommended to hard code in java program because
				if there is any change to reflect that change recompilation, rebuild, and redeploy application are required even some times server restart also required
				which creates a big business impact to the client 
				
			2) we can overcome this problem by using properties file such type of variable things we have to configure in the properties file 
			
			3) from that properties file we have to read in to java program and we have to use those properties
			
			4) the main advancetage of this approach is if there is change in properties file to reflect that change just redeploy is enough which want create any business
				impact to the client
				
			5) we can use java properties object to hold properties which are coming from properties file 
			
			6) in normal Map(like HashMap, Hashtable, TreeMap) key and value can be any type but in the case of properties key and value should be String type 
			
			
			
	constructors -
			
			Properties p = new Properties();
			
			
			
	Methods -
			
			1) String setProperty(String pname, String vname) -
					- to set a new Property
					- if the specified property already available then old value will be replaced with new value and returns old value 
						
			2) String getProperty(String pname)  -
					- to get the associated with the specified property
					- if the specified property is not available then this method return null
						
								
			3) Enumeration 	propertyNames()  -
					- returns all property names present in Property Object
					
					
					
					
													load()									
					
					Properties file			------------------------------------>			Java Properties Object
											<---------------------------------
													store()
			
					abc.properties														Properties p = new Properties();
					
					
			
			4) void load(InputStream is) -
					- to load properties from properties file into java properties object
					
			5) void store(OutputStream os, String comment)  -
					- to store properties from java properties object into properties file.
					
					
					
					
	Example  -
				abc.properties
				
				user = scott
				venki = 999
				pwd  = tiger
			
			
			
				
				import java.util.*;
				import java.io.*;
				
				class PropertiesDemo{
				
					public static void main(String [] args) throws Exception{
					
						Properties p = new Properties();
						FileInputStream fis = new FileInputStream("abc.properties");
						p.load(fis);
						System.out.println(p);							// {user = scott, venki = 999, pwd  = tiger}
						
						String s = p.getProperty("venki");
						System.out.println(s);							// 999
						
						p.setProperty("nag", "8888");
						
						FileOutputStream fos = new FileOutputStream("abc.properties");
						p.store(fos, "Updated by Rushi for properties value");
					}
						
				}
					
			
			
				abc.properties
				
				
				#Updated by Rushi for properties value
				#Sun Sep 21 19:04:39 IST 2023
				user = scott
				venki = 999
				pwd  = tiger
			
			
			
			
			
	Example -
			
				import java.util.*;
				import java.io.*;
				
				class PropertiesDemo{
				
					public static void main(String [] args) throws Exception{
					
						Properties p = new Properties();
						FileInputStream fis = new FileInputStream("db.properties");
						p.load(fis);
						
						String url = p.getProperty("url");
						String user = p.getProperty("user");
						String pwd = p.getProperty("pwd");
						
						Connection con = DriverManager.getConnection(url, user, pwd);
						
						;;;;;
					}
						
				}
			
			
			
			
-------------------------------------------------------------------------------------------------------------------------------------------------------------


Queue   -
			
			
		1.5 version enhancement (Queue interface)
			
			1) it is child interface of Collection
			
			
					
													
															
																Collection(I) 1.2
																
																
									List(I) 1.2											Set(I) 1.2												Queue(I) 1.5
															1.5																						|
										-------------------------------------------------------------------------------------------------------------						
										|										
			ArrayList(C) 1.2	LinkedList(C) 1.2	Vector(C) 1.0																		PriorityQueue1.5  BlockingQueue	1.5			
																
																
													Stack(C) 1.0																						PriorityBlockingQueue 1.5
																
																
																																						LinkedBlockingQueue 1.5
																
																
			
			
			
			
			1) if we want to represent a group og indiviual objects prior to processing then we should go for Queue
			eg -
				before sending SMS message all mobile-no we have to store in some data structure in which order we added mobile-no in the same order only message should be 
				delivered for this FIFO required Queue is best choice
				
			2) usaully Queue follows FIFO order but based on our requirement we can implement our own priority order also(PriorityQueue)
			
			3) 1.5 version onward LinkedList class also implement Queue interface 
			
			4) LinkedList based implementation of Queue always follows FIFO
		
		
			
	

	Methods  -
		
			1) boolean offer(Object o) -
					- to add an Object into the queue
					
			2) Object peek() -
					- to return head element of the queue. if queue is empty then this method returns null
					
			3) Object element() -
					- to return head element of the queue if the queue is empty then this method raise RE : NoSuchElementException
					
			4) Object poll() -
					- to remove and return head element of the queue. if queue is empty then this method return null.
					
			5) Object remove() -
					- to remove and return head element of the queue. if queue is empty then this method raise RE : NoSuchElementException





--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


PriorityQueue  -

			1) if we want to represent a group of indiviual Objects prior to processing according to some priority then we should go for PriorityQueue
			2) the priority can be either default natural sorting order and customized sorting order defined by Comparator
			3) insertion order not preserved and it is based on some priority
			4) duplicate object are not allowed
			5) if we are depending on default sorting order compulsary Object should be homogeneous and comaparable otherwise we will get runtime exception saying
				ClassCastException
			6) if we are defining our own sorting by Comparator then Object need not be homogeneous and comaparable
			7) null is not allowed even as the first element also
			
			
	
	constructors  -
			
			1) PriorityQueue pq = new PriorityQueue() -		// 11	Default natural sorting order
								
			
			1) PriorityQueue pq = new PriorityQueue(int initialCapacity) -
			
			1) PriorityQueue pq = new PriorityQueue(int initialCapacity, Comparator c) -	customized sorting order
			
			1) PriorityQueue pq = new PriorityQueue(SortedSet s) -
			
			1) PriorityQueue pq = new PriorityQueue(Collection c) -
			


	Example  -
			
				import java.util.*;
				
				class PriorityQueueDemo{
				
					public static void main(String [] args) throws Exception{
					
						PriorityQueue pq = new PriorityQueue();
						
						System.out.println(pq.peek());					// null
						System.out.println(pq.element());				// RE : NoSuchElementException
						
						for(int i=0; i<=10; i++){
						
							pq.offer(i);
						}
						
						System.out.println(pq);					// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
						System.out.println(pq.poll());			// 0	
						System.out.println(pq);					// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
					}
						
				}


	Note -
			
			1) some platform want provide proper support for Thread priority and PriorityQueue 




Customized PriorityQueue -
		
		
				import java.util.*;
				
				class PriorityQueueDemo{
				
					public static void main(String [] args) throws Exception{
					
						PriorityQueue pq = new PriorityQueue(15, new MyComparator());
						pq.offer("A");
						pq.offer("Z");
						pq.offer("L");
						pq.offer("B");
						
						System.out.println(pq);							// [Z, L, B, A]
					}
						
				}
				
				class MyComparator implements Comparator{
				
					public int compare(Object o1, Object o2){
						
						String s1 = o1.toString();
						String s2 = (String) o2;
						
						return s2.compareTo(s1);
					}
				}



----------------------------------------------------------------------------------------------------------------------------------------------------------------------


1.6 version enhancement in Collection Framework  -
		
		
			1) as part of 1.6 version the following two concept introduced in Collection Framework  -
			
				1) NavigableSet
				2) NavigableMap
				
				
				
	1) NavigableSet (I)  -
		
		
			1) it is child interface of SortedSet and it defines several methods for Navigation purposes
			
				

	
		Methods -
			
			1) floor(e)  -
					it returns highest element which is <= e
					
			2) lower(e)  -
					it returns highest element which is < e

			3) ceiling(e)  -
					it returns lowest element which is >= e

			4) higher(e)  -
					it returns lowest element which is > e
					
					
			5) pollFirst()  -
					remove and return first element


			6) pollLasst()  -
					remove and return last element
					
			7) descendingSet() -
					it returns NavigableSet in reverse order
					
					
					
					
	Example -
			
			import java.util.*;
				
				class NavigableSetDemo{
				
					public static void main(String [] args) throws Exception{
					
						TreeSet<Integer> t = new TreeSet<Integer>();
						t.add(1000);
						t.add(2000);
						t.add(3000);
						t.add(4000);
						t.add(5000);
						System.out.println(t);							// [1000, 2000, 3000, 4000, 5000]
						
						System.out.println(t.ceiling(2000));			// 2000
						System.out.println(t.higher(2000));				// 3000
						System.out.println(t.floor(3000));				// 3000
						System.out.println(t.lower(3000));				// 2000
						System.out.println(t.pollFirst());				// 1000
						System.out.println(t.pollLast());				// 5000
						
						System.out.println(t.descendingSet());			// [4000, 3000, 2000]
						System.out.println(t);							// [2000, 3000, 4000]
					}
						
				}
				
					
					
					
					
----------------------------------------------------------------------------------------------------------------------------------------------------------------------


NavigableMap(I)   -

			
			1) NavigableMap is child interface of SortedMap
			2) it defines several methods for navigation purposes
			
	
		Methods -
		
			
			1) floorKey(e)  -
					it returns highest element which is <= e
					
			2) lowerKey(e)  -
					it returns highest element which is < e

			3) ceilingKey(e)  -
					it returns lowest element which is >= e

			4) higherKey(e)  -
					it returns lowest element which is > e
					
					
			5) pollFirstEntry()  -
					remove and return first element


			6) pollLasstEntry()  -
					remove and return last element
					
			7) descendingMap() -
					it returns NavigableSet in reverse order
							
					
					
	Example -
			
				import java.util.*;
				
				class NavigableMapDemo{
				
					public static void main(String [] args) throws Exception{
					
						TreeSet<String, String> t = new TreeSet<String, String>();
						t.put("b", "banana");
						t.put("c", "cat");
						t.put("a", "apple");
						t.put("d", "dog");
						t.put("g", "gun");
						System.out.println(t);							// [a=apple, b=banana, c=cat, d=dog, g=gun]
						
						System.out.println(t.ceilingKey("c"));				// c
						System.out.println(t.higherKey("e"));				// g
						System.out.println(t.floorKey("e"));				// d
						System.out.println(t.lowerKey("e"));				// d
						System.out.println(t.pollFirstEntry());				// a=apple
						System.out.println(t.pollLastEntry());				// g=gun
						
						System.out.println(t.descendingMap());			// [d=dog, c=cat, b=banana]
						System.out.println(t);							// [b=banana, c=cat, d=dog]
					}
						
				}				
					
					
					
					
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


Collections(C)  -
						
					
			1) Collections class defines several utility methods for Collection Objects like Sorting, searching, reversing etc.
			
			
			Sorting element of List -
					Collections class defines the following two Sort methods 
					
				1) public static void sort(List l) -
						- to sort based Default Natural sorting order
						- in this case List should compulsary contains homogeneous and comaparable objects otherwise we will get RE : ClassCastException
						- List should not contain null otherwise we will get nullPointerException
						
				
				2) public static void sort(List l, Comparator c) -	
						- to sort based Customized sorting order
					
					
					
	Example -
	
		Default natural sorting order -
			
				import java.util.*;
				
				class CollectionsSortDemo{
				
					public static void main(String [] args){
					
						ArrayList a = new ArrayList();
						a.add("Z");
						a.add("A");
						a.add("K");
						a.add("N");
						
						a.add(new Integer(10));				// ClassCastException
						a.add(null);						// nullPointerException
						
						
						System.out.println("Before Sorting :" + a);		[Z, A, K, N]
						Collections.sort(a)
						System.out.println("After Sorting :" + a);		[A, K, N, Z]
					
					}
					
				}
									
					


		customized sorting order -
			
			
				import java.util.*;
				
				class CollectionsSortDemo{
				
					public static void main(String [] args){
					
						ArrayList a = new ArrayList();
						a.add("Z");
						a.add("A");
						a.add("K");
						a.add("L");
					
						
						System.out.println("Before Sorting :" + a);		[Z, A, K, L]
						Collections.sort(a, new MyComparator());
						System.out.println("After Sorting :" + a);		[Z, L, K, A]
					
					}
					
				}
			
			
				class MyComparator implements Comparator{
				
					public int compare(Object o1, Object o2){
						
						String s1 = o1.toString();
						String s2 = (String) o2;
						
						return s2.compareTo(s1);
					}
				}
			
			


---------------------------------------------------------------------------------------------------------------------------------------------------------------------

searching element of List - 			
		
		Collections class defines the following binerySearch methods  -
				
			1) public static int binerySearch(List l, Object target)  -
					- if the list is Sorted according to default natural sorting order then we have to use this method
			
			2) public static int binerySearch(List l, Object target, Comparator c)  -
					- we have to use this method if the list is Sorted according to customized sorting order
					
					
					
	conclusions -
		
		1) by above search method internally will use binerySearch algorithm 
		2) successful search returns index 
		3) unsuccessful returns insertion point
		4) insertion point is the location where we can place target element in sorting list
		5) before calling binerySearch() method compulsary list should be sorted otherwise we will get unpredicatable results 
		6) if the list is sorted according to Comparator then at the time of search operation also we have to pass same Comparator Object otherwise we will get
			unpredicatable results
		
		
		
	Example -
			
				import java.util.*;
				
				class CollectionsSearchDemo{
				
					public static void main(String [] args){
					
						ArrayList l = new ArrayList();
						l.add("Z");
						l.add("A");
						l.add("M");
						l.add("K");
						l.add("a");
						
						System.out.println(l);									// [Z, A, M, K, a]	
						Collections.sort(l);									
						
						System.out.println(l);									// [A, K, M, Z, a]	
						
						System.out.println(Collections.binerySearch(l, "Z"));	// 3
						System.out.println(Collections.binerySearch(l, "J"));	//	-2
					}
				}
		
		
		
		l  =	Z 			A			M 			K 			a 
			
			
				-1			-2			-3			-4			-5			insertion point
				
				A 			K 			M    		Z  			a 			list  
		
				0			1			2			3			4			index
		
		
		
		
		
		
using Comparator  -
			
			
				import java.util.*;
				
				class CollectionsSearchDemo{
				
					public static void main(String [] args){
					
						ArrayList l = new ArrayList();
						l.add(15);
						l.add(0);
						l.add(20);
						l.add(10);
						l.add(5);
						
						System.out.println(l);									// [15, 0, 20, 10, 5]	
						Collections.sort(l, new MyComparator());									
						
						System.out.println(l);									// [20, 15, 10, 5, 0]	
						
						System.out.println(Collections.binerySearch(l, 10, new MyComparator()));		// 2
						System.out.println(Collections.binerySearch(l, 13, new MyComparator()));		//	-3
						System.out.println(Collections.binerySearch(l, 17));							//	unpredicatable results
						System.out.println(Collections.binerySearch(l, 17, new Comparator()));			// -2		
					}
				}
		
		
		
			class MyComparator implements Comparator{
				
					public int compare(Object o1, Object o2){
						
						Integer i1 = (Integer)o1;
						Integer i2 = (Integer) o2;
						
						return i2.compareTo(i1);
					}
				}
		
		
				15			 0			 20			 10			 5			List
		
		
				-1			-2			-3			-4			-5			insertion point
				
				20 			15 			10    		5 			0 			list  
		
				0			1			2			3			4			index
		
		
		
		
		
		Note -
				 for the list of n elements , in the case of binerySearch method 
				 
				 1) successful serach results range - 		0 to n-1
				 2) unsuccessful serach results range -		-(n+1) to -1
				 3) total results range  -					-(n+1) to n-1
				 
		
		
			eg -
					3 - elements
					
					
					-1		-2		-3		-4
					
					A 		K 		Z 
					
					0		1		2
		
		
		
				 1) successful serach results range - 		0 to 2
				 2) unsuccessful serach results range -		-4 to -1
				 3) total results range  -					-4 to 2
				 
				 
				 
				 
				 
				 
				 
--------------------------------------------------------------------------------------------------------------------------------------------------------------


Reversing elements of List  -

			
			1) Collections class defines the following reverse method to reverse elements of list
				
				
				public static void reverse(List l)  -
				
				
			eg -
			
					import java.util.*;
				
					class CollectionsReverseDemo{
				
					public static void main(String [] args){
					
						ArrayList l = new ArrayList();
						l.add(15);
						l.add(0);
						l.add(20);
						l.add(10);
						l.add(5);
						
						System.out.println(l);									// [15, 0, 20, 10, 5]							
						Collections.reverse(l);									
						
						System.out.println(l);									// [5, 10, 20, 0, 15]	
						
					}
				}
				
				
				
				
				
				
	reverse() vs reverseOrder()  -
		
		1) we can use reverse() to reverse order of element of list 
		2) where as we can use reverseOrder() to get reversed Comparator 
		
		
		eg -
			Comparator c = Collections.reverseOrder(Comparator c);
						|									|
				descending order					Assecding order
				
				
				
				
				
---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Arrays  -				
			
			
			1) Arrays class is an utility class to define several utility methods for Arrays objects 
				
				
				
	1) Sorting elements fo Array  -
			
		Arrays class  define the following sort methods to sort elements of primitive and Object type Array
		
			1) public static void sort(primitive[] p)  -
					- to Sort according to default natural sorting order
					
			2) public static void sort(Object[] o)  -
					- to Sort according to default natural sorting order
				
			3) public static void sort(Object[] o, Comparator c)  -
					- to Sort according to customized sorting order	
					
					
					
	Example  -
				import java.util.*;
				import java.util.Comparator;
				
				class ArraysSortDemo{
				
					public static void main(String[] args){
					
						int[] a = {10, 5, 20, 11, 6};
						
						System.out.println("Primitive Object before Sorting :");		
						
						for(int a1: a){
							System.out.println(a1);								// 10, 5, 20, 11, 6							
						}
						
						Arrays.sort(a);
						
						System.out.println("Primitive Object After Sorting :");
						
						for(int a1: a){
							System.out.println(a1);								// 5, 6, 10, 11, 20
						}
						
						
						
						
						String[] s ={"A", "Z", "B"};
						
						System.out.println("Object Array before Sorting :");		
						
						for(String s1: s){
							System.out.println(s1);								// A, Z, B							
						}
						
						Arrays.sort(s);
						
						System.out.println("Object Array After Sorting :");
						
						for(String s1: s){
							System.out.println(s1);								// A, B, Z	
						}
						
						
						
						
						Arrays.sort(s, new MyComparator());
						System.out.println("Object Array After Sorting by Comparable :");
						
						for(String s1: s){
							System.out.println(s1);								// Z, B, A	
						}
						
					}
				}
				
				
				
				
				class MyComparator implements Comparator{
				
					public int compare(Object o1, Object o2){
						
						String s1 = o1.toString();
						String s2 = o2.toString();
						
						return s2.compareTo(s1);
					}
				}
				
				
	Note  -
			
			1) we can sort primitive arrays only based on default natural sorting order where as we can sort Object arrays on based on default natural sorting order
				or based on customized sorting order
				
				
				
				
				
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


searching elements of Array   -

		
			Arrays class defines the following binerySearch methods  
			
			1) public static int binerySearch(primitive[] p, primitive target)  -
					
			
			2) public static int binerySearch(Object[] o, Object target)  -
			
			
			3) public static int binerySearch(Object[] o, Object target, Comparator c)  -
						
				
				
	Note -	

		1) all rules of Arrays class binerySearch method as exactly same as Collections class binerySearch methods
		
	

	Example -
	
	
				import java.util.*;
				
				class CollectionsSearchDemo{
				
					public static void main(String [] args){
					
						int[] a = {10, 5, 20, 11, 6};
						
						Arrays.sort(a);
						
						System.out.println(Arrays.binerySearch(a, 6));									// 1	
						System.out.println(Arrays.binerySearch(a, 14));									// -5							
						
						String[] s ={"A", "Z", "B"};
						Arrays.sort(s);
						
						System.out.println(binerySearch(s, "Z"));									// 2	
						System.out.println(binerySearch(s, "S"));									// -3	
						
						Arrays.sort(s, new Comparator());
						System.out.println(binerySearch(s, "Z", new MyComparator()));		// 0
						System.out.println(binerySearch(s, "S", new MyComparator()));		//	-2
						System.out.println(binerySearch(s, "N"));							//	unpredicatable results
								
					}
				}
		
		
		
			class MyComparator implements Comparator{
				
					public int compare(Object o1, Object o2){
						
						String s1 = o1.toString();
						String s2 = o2.toString();
						
						return s2.compareTo(s1);
					}
				}	
		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


				
Conversion of Array to List   -


			1) public static List asList(Object[] o)  -
			
				Strictly Speaking this method wont create an indepedent list object for the existing Array we are getting List View 
			
				String[] s = {"A", "Z", "B"};
				
				List l = Arrays.asList(s);		
				
				
						list l --->  	A		Z 		B 		---> String[] s
						
						
			2) by using Array reference we can perform any change automatically that change will be reflected to the List similarly 
			   by using List reference if we perform any change that change will be reflected automatically to the Array 
			   
			   
			3) by using list reference we cant perform any operation which varies the size otherwise we will get RE : UnSupportedOperationException
			
					l.add("M");
					l.remove(1);
					
					but 
					l.set(1, "N");
					
					
					
			4) by using list reference we are not allowed to replaced with hetrogenuaus objects otherwise we will get RE : ArrayStoreException
			
					l.set(1, new Integer(10));		// RE : ArrayStoreException
			
			
			
			
	Example -
		
				import java.util.*;
				
				class ArraysAsListDemo{
				
					public static void main(String[] args){
					
						String[] s ={"A", "Z", "B"};
						
						List l = Arrays.asList(s);
						System.out.println(l);				// [A, Z, B]
						
						s[0] = "K";	
						System.out.println(l);				// [K, Z, B]	

						l.set(1,"L");
						
						for(String s1: s)
							System.out.println(s1);			// K, L, B
							
						l.add("Durga");						// UnSupportedOperationException
						l.remove(2);						// UnSupportedOperationException
						l.set(1, new Integer(10));			// ArrayStoreException
					}
				}
			
			
			
			
			
					